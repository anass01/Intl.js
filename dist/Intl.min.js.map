{"version":3,"file":null,"sources":["../src/util.js","../src/6.locales-currencies-tz.js","../src/9.negotiation.js","../src/8.intl.js","../src/11.numberformat.js","../src/cldr.js","../src/12.datetimeformat.js","../src/14.pluralrules.js","../src/core.js","../src/exp.js","../src/13.locale-sensitive-functions.js","../node_modules/make-plural/es6/plurals.js","../src/browser-main.js"],"sourcesContent":["const realDefineProp = (function () {\r\n        let sentinel = function(){};\r\n        try {\r\n            Object.defineProperty(sentinel, 'a', {\r\n                get: function () {\r\n                    return 1;\r\n                }\r\n            });\r\n            Object.defineProperty(sentinel, 'prototype', { writable: false });\r\n            return sentinel.a === 1 && sentinel.prototype instanceof Object;\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n    })();\r\n\r\n// Need a workaround for getters in ES3\r\nexport const es3 = !realDefineProp && !Object.prototype.__defineGetter__;\r\n\r\n// We use this a lot (and need it for proto-less objects)\r\nexport const hop = Object.prototype.hasOwnProperty;\r\n\r\n// Naive defineProperty for compatibility\r\nexport const defineProperty = realDefineProp ? Object.defineProperty : function (obj, name, desc) {\r\n    if ('get' in desc && obj.__defineGetter__)\r\n        obj.__defineGetter__(name, desc.get);\r\n\r\n    else if (!hop.call(obj, name) || 'value' in desc)\r\n        obj[name] = desc.value;\r\n};\r\n\r\n// Array.prototype.indexOf, as good as we need it to be\r\nexport const arrIndexOf = Array.prototype.indexOf || function (search) {\r\n    /*jshint validthis:true */\r\n    let t = this;\r\n    if (!t.length)\r\n        return -1;\r\n\r\n    for (let i = arguments[1] || 0, max = t.length; i < max; i++) {\r\n        if (t[i] === search)\r\n            return i;\r\n    }\r\n\r\n    return -1;\r\n};\r\n\r\n// Create an object with the specified prototype (2nd arg required for Record)\r\nexport const objCreate = Object.create || function (proto, props) {\r\n    let obj;\r\n\r\n    function F() {}\r\n    F.prototype = proto;\r\n    obj = new F();\r\n\r\n    for (let k in props) {\r\n        if (hop.call(props, k))\r\n            defineProperty(obj, k, props[k]);\r\n    }\r\n\r\n    return obj;\r\n};\r\n\r\n// Snapshot some (hopefully still) native built-ins\r\nexport const arrSlice  = Array.prototype.slice;\r\nexport const arrConcat = Array.prototype.concat;\r\nexport const arrPush   = Array.prototype.push;\r\nexport const arrJoin   = Array.prototype.join;\r\nexport const arrShift  = Array.prototype.shift;\r\n\r\n// Naive Function.prototype.bind for compatibility\r\nexport const fnBind = Function.prototype.bind || function (thisObj) {\r\n    let fn = this,\r\n        args = arrSlice.call(arguments, 1);\r\n\r\n    // All our (presently) bound functions have either 1 or 0 arguments. By returning\r\n    // different function signatures, we can pass some tests in ES3 environments\r\n    if (fn.length === 1) {\r\n        return function () {\r\n            return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\r\n        };\r\n    }\r\n    return function () {\r\n        return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\r\n    };\r\n};\r\n\r\n// Object housing internal properties for constructors\r\nexport const internals = objCreate(null);\r\n\r\n// Keep internal properties internal\r\nexport const secret = Math.random();\r\n\r\n// Helper functions\r\n// ================\r\n\r\n/**\r\n * A function to deal with the inaccuracy of calculating log10 in pre-ES6\r\n * JavaScript environments. Math.log(num) / Math.LN10 was responsible for\r\n * causing issue #62.\r\n */\r\nexport function log10Floor (n) {\r\n    // ES6 provides the more accurate Math.log10\r\n    if (typeof Math.log10 === 'function')\r\n        return Math.floor(Math.log10(n));\r\n\r\n    let x = Math.round(Math.log(n) * Math.LOG10E);\r\n    return x - (Number('1e' + x) > n);\r\n}\r\n\r\n/**\r\n * A map that doesn't contain Object in its prototype chain\r\n */\r\nexport function Record (obj) {\r\n    // Copy only own properties over unless this object is already a Record instance\r\n    for (let k in obj) {\r\n        if (obj instanceof Record || hop.call(obj, k))\r\n            defineProperty(this, k, { value: obj[k], enumerable: true, writable: true, configurable: true });\r\n    }\r\n}\r\nRecord.prototype = objCreate(null);\r\n\r\n/**\r\n * An ordered list\r\n */\r\nexport function List() {\r\n    defineProperty(this, 'length', { writable:true, value: 0 });\r\n\r\n    if (arguments.length)\r\n        arrPush.apply(this, arrSlice.call(arguments));\r\n}\r\nList.prototype = objCreate(null);\r\n\r\n/**\r\n * Constructs a regular expression to restore tainted RegExp properties\r\n */\r\nexport function createRegExpRestore () {\r\n    if (internals.disableRegExpRestore) {\r\n        return function() { /* no-op */ };\r\n    }\r\n\r\n    let regExpCache = {\r\n            lastMatch: RegExp.lastMatch || '',\r\n            leftContext: RegExp.leftContext,\r\n            multiline: RegExp.multiline,\r\n            input: RegExp.input\r\n        },\r\n        has = false;\r\n\r\n    // Create a snapshot of all the 'captured' properties\r\n    for (let i = 1; i <= 9; i++)\r\n        has = (regExpCache['$'+i] = RegExp['$'+i]) || has;\r\n\r\n    return function() {\r\n        // Now we've snapshotted some properties, escape the lastMatch string\r\n        let esc = /[.?*+^$[\\]\\\\(){}|-]/g,\r\n            lastMatch = regExpCache.lastMatch.replace(esc, '\\\\$&'),\r\n            exprStr = '';\r\n\r\n        // If any of the captured strings were non-empty, iterate over them all\r\n        if (has) {\r\n            for (let i = 1; i <= 9; i++) {\r\n                let m = regExpCache['$'+i];\r\n\r\n                // If it's empty, add an empty capturing group\r\n                if (!m) {\r\n                    exprStr += '(';\r\n                    lastMatch = ')' + lastMatch;\r\n                }\r\n                // Else find the string in lm and escape & wrap it to capture it\r\n                else {\r\n                    m = m.replace(esc, '\\\\$&');\r\n                    exprStr += lastMatch.substring(0, lastMatch.indexOf(m)) + '(';\r\n                    lastMatch = m + ')' + lastMatch.substring(lastMatch.indexOf(m) + m.length);\r\n                }\r\n            }\r\n        }\r\n\r\n        exprStr += lastMatch;\r\n\r\n        // Shorten the regex by replacing each part of the expression with a match\r\n        // for a string of that exact length.  This is safe for the type of\r\n        // expressions generated above, because the expression matches the whole\r\n        // match string, so we know each group and each segment between capturing\r\n        // groups can be matched by its length alone.\r\n        //\r\n        // The purpose of the regex is to match sequences of characters other\r\n        // than unescaped parentheses.  This is a more complicated requirement\r\n        // than it seems at first glance, because it's necessary to match a\r\n        // parenthesis which appears immediately after a backslash (\"\\(\"), but\r\n        // not a parenthesis which appears immediately after an escaped backslash\r\n        // (\"\\\\(\").  We can't simply match [^\\\\]\\\\(, because the previous\r\n        // backslash could itself have a backslash preceding (and escaping) it.\r\n        //\r\n        // Any attempts to simplify this regex are encouraged!  A replacement\r\n        // regex should match the strings \"a\\\\\\(\\\\\\)\\\\\" and \"a\\\\\\)\\\\\\(\" in the\r\n        // test string \"a\\\\\\(\\\\\\)\\\\(a\\\\\\)\\\\\\()\".\r\n        exprStr = exprStr.replace(/((^|[^\\\\])((\\\\\\\\)*\\\\[()])+|[^()])+/g, (match) => {\r\n            return `[\\\\s\\\\S]{${match.replace(/\\\\(.)/g, '$1').length}}`;\r\n        });\r\n\r\n        // Create the regular expression that will reconstruct the RegExp properties\r\n        let expr = new RegExp(exprStr, regExpCache.multiline ? 'gm' : 'g');\r\n\r\n        // Set the lastIndex of the generated expression to ensure that the match\r\n        // is found in the correct index.\r\n        expr.lastIndex = regExpCache.leftContext.length;\r\n\r\n        expr.exec(regExpCache.input);\r\n    };\r\n}\r\n\r\n/**\r\n * Mimics ES5's abstract ToObject() function\r\n */\r\nexport function toObject (arg) {\r\n    if (arg === null)\r\n        throw new TypeError('Cannot convert null or undefined to object');\r\n\r\n    if (typeof arg === 'object')\r\n        return arg;\r\n    return Object(arg);\r\n}\r\n\r\nexport function toNumber (arg) {\r\n    if (typeof arg === 'number')\r\n        return arg;\r\n    return Number(arg);\r\n}\r\n\r\nexport function toInteger (arg) {\r\n  let number = toNumber(arg);\r\n  if (isNaN(number))\r\n      return 0;\r\n  if (number === +0 ||\r\n      number === -0 ||\r\n      number === +Infinity ||\r\n      number === -Infinity)\r\n      return number;\r\n  if (number < 0)\r\n      return Math.floor(Math.abs(number)) * -1;\r\n  return Math.floor(Math.abs(number));\r\n}\r\n\r\nexport function toLength (arg) {\r\n  let len = toInteger(arg);\r\n  if (len <= 0)\r\n      return 0;\r\n  if (len === Infinity)\r\n      return Math.pow(2, 53) - 1;\r\n  return Math.min(len, Math.pow(2, 53) - 1);\r\n}\r\n\r\n/**\r\n * Returns \"internal\" properties for an object\r\n */\r\nexport function getInternalProperties (obj) {\r\n    if (hop.call(obj, '__getInternalProperties'))\r\n        return obj.__getInternalProperties(secret);\r\n\r\n    return objCreate(null);\r\n}\r\n","// Sect 6.2 Language Tags\r\n// ======================\r\n\r\nimport {\r\n    expBCP47Syntax,\r\n    expExtSequences,\r\n    expVariantDupes,\r\n    expSingletonDupes\r\n} from './exp';\r\n\r\nimport {\r\n    hop,\r\n    arrJoin,\r\n    arrSlice\r\n} from \"./util.js\";\r\n\r\n// Default locale is the first-added locale data for us\r\nexport let defaultLocale;\r\nexport function setDefaultLocale(locale) {\r\n    defaultLocale = locale;\r\n}\r\n\r\n// IANA Subtag Registry redundant tag and subtag maps\r\nconst redundantTags = {\r\n    tags: {\r\n        \"art-lojban\": \"jbo\",\r\n        \"i-ami\": \"ami\",\r\n        \"i-bnn\": \"bnn\",\r\n        \"i-hak\": \"hak\",\r\n        \"i-klingon\": \"tlh\",\r\n        \"i-lux\": \"lb\",\r\n        \"i-navajo\": \"nv\",\r\n        \"i-pwn\": \"pwn\",\r\n        \"i-tao\": \"tao\",\r\n        \"i-tay\": \"tay\",\r\n        \"i-tsu\": \"tsu\",\r\n        \"no-bok\": \"nb\",\r\n        \"no-nyn\": \"nn\",\r\n        \"sgn-BE-FR\": \"sfb\",\r\n        \"sgn-BE-NL\": \"vgt\",\r\n        \"sgn-CH-DE\": \"sgg\",\r\n        \"zh-guoyu\": \"cmn\",\r\n        \"zh-hakka\": \"hak\",\r\n        \"zh-min-nan\": \"nan\",\r\n        \"zh-xiang\": \"hsn\",\r\n        \"sgn-BR\": \"bzs\",\r\n        \"sgn-CO\": \"csn\",\r\n        \"sgn-DE\": \"gsg\",\r\n        \"sgn-DK\": \"dsl\",\r\n        \"sgn-ES\": \"ssp\",\r\n        \"sgn-FR\": \"fsl\",\r\n        \"sgn-GB\": \"bfi\",\r\n        \"sgn-GR\": \"gss\",\r\n        \"sgn-IE\": \"isg\",\r\n        \"sgn-IT\": \"ise\",\r\n        \"sgn-JP\": \"jsl\",\r\n        \"sgn-MX\": \"mfs\",\r\n        \"sgn-NI\": \"ncs\",\r\n        \"sgn-NL\": \"dse\",\r\n        \"sgn-NO\": \"nsl\",\r\n        \"sgn-PT\": \"psr\",\r\n        \"sgn-SE\": \"swl\",\r\n        \"sgn-US\": \"ase\",\r\n        \"sgn-ZA\": \"sfs\",\r\n        \"zh-cmn\": \"cmn\",\r\n        \"zh-cmn-Hans\": \"cmn-Hans\",\r\n        \"zh-cmn-Hant\": \"cmn-Hant\",\r\n        \"zh-gan\": \"gan\",\r\n        \"zh-wuu\": \"wuu\",\r\n        \"zh-yue\": \"yue\"\r\n    },\r\n    subtags: {\r\n        BU: \"MM\",\r\n        DD: \"DE\",\r\n        FX: \"FR\",\r\n        TP: \"TL\",\r\n        YD: \"YE\",\r\n        ZR: \"CD\",\r\n        heploc: \"alalc97\",\r\n        'in': \"id\",\r\n        iw: \"he\",\r\n        ji: \"yi\",\r\n        jw: \"jv\",\r\n        mo: \"ro\",\r\n        ayx: \"nun\",\r\n        bjd: \"drl\",\r\n        ccq: \"rki\",\r\n        cjr: \"mom\",\r\n        cka: \"cmr\",\r\n        cmk: \"xch\",\r\n        drh: \"khk\",\r\n        drw: \"prs\",\r\n        gav: \"dev\",\r\n        hrr: \"jal\",\r\n        ibi: \"opa\",\r\n        kgh: \"kml\",\r\n        lcq: \"ppr\",\r\n        mst: \"mry\",\r\n        myt: \"mry\",\r\n        sca: \"hle\",\r\n        tie: \"ras\",\r\n        tkk: \"twm\",\r\n        tlw: \"weo\",\r\n        tnf: \"prs\",\r\n        ybd: \"rki\",\r\n        yma: \"lrr\"\r\n    },\r\n    extLang: {\r\n        aao: [\"aao\", \"ar\"],\r\n        abh: [\"abh\", \"ar\"],\r\n        abv: [\"abv\", \"ar\"],\r\n        acm: [\"acm\", \"ar\"],\r\n        acq: [\"acq\", \"ar\"],\r\n        acw: [\"acw\", \"ar\"],\r\n        acx: [\"acx\", \"ar\"],\r\n        acy: [\"acy\", \"ar\"],\r\n        adf: [\"adf\", \"ar\"],\r\n        ads: [\"ads\", \"sgn\"],\r\n        aeb: [\"aeb\", \"ar\"],\r\n        aec: [\"aec\", \"ar\"],\r\n        aed: [\"aed\", \"sgn\"],\r\n        aen: [\"aen\", \"sgn\"],\r\n        afb: [\"afb\", \"ar\"],\r\n        afg: [\"afg\", \"sgn\"],\r\n        ajp: [\"ajp\", \"ar\"],\r\n        apc: [\"apc\", \"ar\"],\r\n        apd: [\"apd\", \"ar\"],\r\n        arb: [\"arb\", \"ar\"],\r\n        arq: [\"arq\", \"ar\"],\r\n        ars: [\"ars\", \"ar\"],\r\n        ary: [\"ary\", \"ar\"],\r\n        arz: [\"arz\", \"ar\"],\r\n        ase: [\"ase\", \"sgn\"],\r\n        asf: [\"asf\", \"sgn\"],\r\n        asp: [\"asp\", \"sgn\"],\r\n        asq: [\"asq\", \"sgn\"],\r\n        asw: [\"asw\", \"sgn\"],\r\n        auz: [\"auz\", \"ar\"],\r\n        avl: [\"avl\", \"ar\"],\r\n        ayh: [\"ayh\", \"ar\"],\r\n        ayl: [\"ayl\", \"ar\"],\r\n        ayn: [\"ayn\", \"ar\"],\r\n        ayp: [\"ayp\", \"ar\"],\r\n        bbz: [\"bbz\", \"ar\"],\r\n        bfi: [\"bfi\", \"sgn\"],\r\n        bfk: [\"bfk\", \"sgn\"],\r\n        bjn: [\"bjn\", \"ms\"],\r\n        bog: [\"bog\", \"sgn\"],\r\n        bqn: [\"bqn\", \"sgn\"],\r\n        bqy: [\"bqy\", \"sgn\"],\r\n        btj: [\"btj\", \"ms\"],\r\n        bve: [\"bve\", \"ms\"],\r\n        bvl: [\"bvl\", \"sgn\"],\r\n        bvu: [\"bvu\", \"ms\"],\r\n        bzs: [\"bzs\", \"sgn\"],\r\n        cdo: [\"cdo\", \"zh\"],\r\n        cds: [\"cds\", \"sgn\"],\r\n        cjy: [\"cjy\", \"zh\"],\r\n        cmn: [\"cmn\", \"zh\"],\r\n        coa: [\"coa\", \"ms\"],\r\n        cpx: [\"cpx\", \"zh\"],\r\n        csc: [\"csc\", \"sgn\"],\r\n        csd: [\"csd\", \"sgn\"],\r\n        cse: [\"cse\", \"sgn\"],\r\n        csf: [\"csf\", \"sgn\"],\r\n        csg: [\"csg\", \"sgn\"],\r\n        csl: [\"csl\", \"sgn\"],\r\n        csn: [\"csn\", \"sgn\"],\r\n        csq: [\"csq\", \"sgn\"],\r\n        csr: [\"csr\", \"sgn\"],\r\n        czh: [\"czh\", \"zh\"],\r\n        czo: [\"czo\", \"zh\"],\r\n        doq: [\"doq\", \"sgn\"],\r\n        dse: [\"dse\", \"sgn\"],\r\n        dsl: [\"dsl\", \"sgn\"],\r\n        dup: [\"dup\", \"ms\"],\r\n        ecs: [\"ecs\", \"sgn\"],\r\n        esl: [\"esl\", \"sgn\"],\r\n        esn: [\"esn\", \"sgn\"],\r\n        eso: [\"eso\", \"sgn\"],\r\n        eth: [\"eth\", \"sgn\"],\r\n        fcs: [\"fcs\", \"sgn\"],\r\n        fse: [\"fse\", \"sgn\"],\r\n        fsl: [\"fsl\", \"sgn\"],\r\n        fss: [\"fss\", \"sgn\"],\r\n        gan: [\"gan\", \"zh\"],\r\n        gds: [\"gds\", \"sgn\"],\r\n        gom: [\"gom\", \"kok\"],\r\n        gse: [\"gse\", \"sgn\"],\r\n        gsg: [\"gsg\", \"sgn\"],\r\n        gsm: [\"gsm\", \"sgn\"],\r\n        gss: [\"gss\", \"sgn\"],\r\n        gus: [\"gus\", \"sgn\"],\r\n        hab: [\"hab\", \"sgn\"],\r\n        haf: [\"haf\", \"sgn\"],\r\n        hak: [\"hak\", \"zh\"],\r\n        hds: [\"hds\", \"sgn\"],\r\n        hji: [\"hji\", \"ms\"],\r\n        hks: [\"hks\", \"sgn\"],\r\n        hos: [\"hos\", \"sgn\"],\r\n        hps: [\"hps\", \"sgn\"],\r\n        hsh: [\"hsh\", \"sgn\"],\r\n        hsl: [\"hsl\", \"sgn\"],\r\n        hsn: [\"hsn\", \"zh\"],\r\n        icl: [\"icl\", \"sgn\"],\r\n        ils: [\"ils\", \"sgn\"],\r\n        inl: [\"inl\", \"sgn\"],\r\n        ins: [\"ins\", \"sgn\"],\r\n        ise: [\"ise\", \"sgn\"],\r\n        isg: [\"isg\", \"sgn\"],\r\n        isr: [\"isr\", \"sgn\"],\r\n        jak: [\"jak\", \"ms\"],\r\n        jax: [\"jax\", \"ms\"],\r\n        jcs: [\"jcs\", \"sgn\"],\r\n        jhs: [\"jhs\", \"sgn\"],\r\n        jls: [\"jls\", \"sgn\"],\r\n        jos: [\"jos\", \"sgn\"],\r\n        jsl: [\"jsl\", \"sgn\"],\r\n        jus: [\"jus\", \"sgn\"],\r\n        kgi: [\"kgi\", \"sgn\"],\r\n        knn: [\"knn\", \"kok\"],\r\n        kvb: [\"kvb\", \"ms\"],\r\n        kvk: [\"kvk\", \"sgn\"],\r\n        kvr: [\"kvr\", \"ms\"],\r\n        kxd: [\"kxd\", \"ms\"],\r\n        lbs: [\"lbs\", \"sgn\"],\r\n        lce: [\"lce\", \"ms\"],\r\n        lcf: [\"lcf\", \"ms\"],\r\n        liw: [\"liw\", \"ms\"],\r\n        lls: [\"lls\", \"sgn\"],\r\n        lsg: [\"lsg\", \"sgn\"],\r\n        lsl: [\"lsl\", \"sgn\"],\r\n        lso: [\"lso\", \"sgn\"],\r\n        lsp: [\"lsp\", \"sgn\"],\r\n        lst: [\"lst\", \"sgn\"],\r\n        lsy: [\"lsy\", \"sgn\"],\r\n        ltg: [\"ltg\", \"lv\"],\r\n        lvs: [\"lvs\", \"lv\"],\r\n        lzh: [\"lzh\", \"zh\"],\r\n        max: [\"max\", \"ms\"],\r\n        mdl: [\"mdl\", \"sgn\"],\r\n        meo: [\"meo\", \"ms\"],\r\n        mfa: [\"mfa\", \"ms\"],\r\n        mfb: [\"mfb\", \"ms\"],\r\n        mfs: [\"mfs\", \"sgn\"],\r\n        min: [\"min\", \"ms\"],\r\n        mnp: [\"mnp\", \"zh\"],\r\n        mqg: [\"mqg\", \"ms\"],\r\n        mre: [\"mre\", \"sgn\"],\r\n        msd: [\"msd\", \"sgn\"],\r\n        msi: [\"msi\", \"ms\"],\r\n        msr: [\"msr\", \"sgn\"],\r\n        mui: [\"mui\", \"ms\"],\r\n        mzc: [\"mzc\", \"sgn\"],\r\n        mzg: [\"mzg\", \"sgn\"],\r\n        mzy: [\"mzy\", \"sgn\"],\r\n        nan: [\"nan\", \"zh\"],\r\n        nbs: [\"nbs\", \"sgn\"],\r\n        ncs: [\"ncs\", \"sgn\"],\r\n        nsi: [\"nsi\", \"sgn\"],\r\n        nsl: [\"nsl\", \"sgn\"],\r\n        nsp: [\"nsp\", \"sgn\"],\r\n        nsr: [\"nsr\", \"sgn\"],\r\n        nzs: [\"nzs\", \"sgn\"],\r\n        okl: [\"okl\", \"sgn\"],\r\n        orn: [\"orn\", \"ms\"],\r\n        ors: [\"ors\", \"ms\"],\r\n        pel: [\"pel\", \"ms\"],\r\n        pga: [\"pga\", \"ar\"],\r\n        pks: [\"pks\", \"sgn\"],\r\n        prl: [\"prl\", \"sgn\"],\r\n        prz: [\"prz\", \"sgn\"],\r\n        psc: [\"psc\", \"sgn\"],\r\n        psd: [\"psd\", \"sgn\"],\r\n        pse: [\"pse\", \"ms\"],\r\n        psg: [\"psg\", \"sgn\"],\r\n        psl: [\"psl\", \"sgn\"],\r\n        pso: [\"pso\", \"sgn\"],\r\n        psp: [\"psp\", \"sgn\"],\r\n        psr: [\"psr\", \"sgn\"],\r\n        pys: [\"pys\", \"sgn\"],\r\n        rms: [\"rms\", \"sgn\"],\r\n        rsi: [\"rsi\", \"sgn\"],\r\n        rsl: [\"rsl\", \"sgn\"],\r\n        sdl: [\"sdl\", \"sgn\"],\r\n        sfb: [\"sfb\", \"sgn\"],\r\n        sfs: [\"sfs\", \"sgn\"],\r\n        sgg: [\"sgg\", \"sgn\"],\r\n        sgx: [\"sgx\", \"sgn\"],\r\n        shu: [\"shu\", \"ar\"],\r\n        slf: [\"slf\", \"sgn\"],\r\n        sls: [\"sls\", \"sgn\"],\r\n        sqk: [\"sqk\", \"sgn\"],\r\n        sqs: [\"sqs\", \"sgn\"],\r\n        ssh: [\"ssh\", \"ar\"],\r\n        ssp: [\"ssp\", \"sgn\"],\r\n        ssr: [\"ssr\", \"sgn\"],\r\n        svk: [\"svk\", \"sgn\"],\r\n        swc: [\"swc\", \"sw\"],\r\n        swh: [\"swh\", \"sw\"],\r\n        swl: [\"swl\", \"sgn\"],\r\n        syy: [\"syy\", \"sgn\"],\r\n        tmw: [\"tmw\", \"ms\"],\r\n        tse: [\"tse\", \"sgn\"],\r\n        tsm: [\"tsm\", \"sgn\"],\r\n        tsq: [\"tsq\", \"sgn\"],\r\n        tss: [\"tss\", \"sgn\"],\r\n        tsy: [\"tsy\", \"sgn\"],\r\n        tza: [\"tza\", \"sgn\"],\r\n        ugn: [\"ugn\", \"sgn\"],\r\n        ugy: [\"ugy\", \"sgn\"],\r\n        ukl: [\"ukl\", \"sgn\"],\r\n        uks: [\"uks\", \"sgn\"],\r\n        urk: [\"urk\", \"ms\"],\r\n        uzn: [\"uzn\", \"uz\"],\r\n        uzs: [\"uzs\", \"uz\"],\r\n        vgt: [\"vgt\", \"sgn\"],\r\n        vkk: [\"vkk\", \"ms\"],\r\n        vkt: [\"vkt\", \"ms\"],\r\n        vsi: [\"vsi\", \"sgn\"],\r\n        vsl: [\"vsl\", \"sgn\"],\r\n        vsv: [\"vsv\", \"sgn\"],\r\n        wuu: [\"wuu\", \"zh\"],\r\n        xki: [\"xki\", \"sgn\"],\r\n        xml: [\"xml\", \"sgn\"],\r\n        xmm: [\"xmm\", \"ms\"],\r\n        xms: [\"xms\", \"sgn\"],\r\n        yds: [\"yds\", \"sgn\"],\r\n        ysl: [\"ysl\", \"sgn\"],\r\n        yue: [\"yue\", \"zh\"],\r\n        zib: [\"zib\", \"sgn\"],\r\n        zlm: [\"zlm\", \"ms\"],\r\n        zmi: [\"zmi\", \"ms\"],\r\n        zsl: [\"zsl\", \"sgn\"],\r\n        zsm: [\"zsm\", \"ms\"]\r\n    }\r\n};\r\n\r\n/**\r\n * Convert only a-z to uppercase as per section 6.1 of the spec\r\n */\r\nexport function toLatinUpperCase (str) {\r\n    let i = str.length;\r\n\r\n    while (i--) {\r\n        let ch = str.charAt(i);\r\n\r\n        if (ch >= \"a\" && ch <= \"z\")\r\n            str = str.slice(0, i) + ch.toUpperCase() + str.slice(i+1);\r\n    }\r\n\r\n    return str;\r\n}\r\n\r\n/**\r\n * The IsStructurallyValidLanguageTag abstract operation verifies that the locale\r\n * argument (which must be a String value)\r\n *\r\n * - represents a well-formed BCP 47 language tag as specified in RFC 5646 section\r\n *   2.1, or successor,\r\n * - does not include duplicate variant subtags, and\r\n * - does not include duplicate singleton subtags.\r\n *\r\n * The abstract operation returns true if locale can be generated from the ABNF\r\n * grammar in section 2.1 of the RFC, starting with Language-Tag, and does not\r\n * contain duplicate variant or singleton subtags (other than as a private use\r\n * subtag). It returns false otherwise. Terminal value characters in the grammar are\r\n * interpreted as the Unicode equivalents of the ASCII octet values given.\r\n */\r\nexport function /* 6.2.2 */IsStructurallyValidLanguageTag(locale) {\r\n    // represents a well-formed BCP 47 language tag as specified in RFC 5646\r\n    if (!expBCP47Syntax.test(locale))\r\n        return false;\r\n\r\n    // does not include duplicate variant subtags, and\r\n    if (expVariantDupes.test(locale))\r\n        return false;\r\n\r\n    // does not include duplicate singleton subtags.\r\n    if (expSingletonDupes.test(locale))\r\n        return false;\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * The CanonicalizeLanguageTag abstract operation returns the canonical and case-\r\n * regularized form of the locale argument (which must be a String value that is\r\n * a structurally valid BCP 47 language tag as verified by the\r\n * IsStructurallyValidLanguageTag abstract operation). It takes the steps\r\n * specified in RFC 5646 section 4.5, or successor, to bring the language tag\r\n * into canonical form, and to regularize the case of the subtags, but does not\r\n * take the steps to bring a language tag into “extlang form” and to reorder\r\n * variant subtags.\r\n\r\n * The specifications for extensions to BCP 47 language tags, such as RFC 6067,\r\n * may include canonicalization rules for the extension subtag sequences they\r\n * define that go beyond the canonicalization rules of RFC 5646 section 4.5.\r\n * Implementations are allowed, but not required, to apply these additional rules.\r\n */\r\nexport function /* 6.2.3 */CanonicalizeLanguageTag (locale) {\r\n    let match, parts;\r\n\r\n    // A language tag is in 'canonical form' when the tag is well-formed\r\n    // according to the rules in Sections 2.1 and 2.2\r\n\r\n    // Section 2.1 says all subtags use lowercase...\r\n    locale = locale.toLowerCase();\r\n\r\n    // ...with 2 exceptions: 'two-letter and four-letter subtags that neither\r\n    // appear at the start of the tag nor occur after singletons.  Such two-letter\r\n    // subtags are all uppercase (as in the tags \"en-CA-x-ca\" or \"sgn-BE-FR\") and\r\n    // four-letter subtags are titlecase (as in the tag \"az-Latn-x-latn\").\r\n    parts = locale.split('-');\r\n    for (let i = 1, max = parts.length; i < max; i++) {\r\n        // Two-letter subtags are all uppercase\r\n        if (parts[i].length === 2)\r\n            parts[i] = parts[i].toUpperCase();\r\n\r\n        // Four-letter subtags are titlecase\r\n        else if (parts[i].length === 4)\r\n            parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].slice(1);\r\n\r\n        // Is it a singleton?\r\n        else if (parts[i].length === 1 && parts[i] !== 'x')\r\n            break;\r\n    }\r\n    locale = arrJoin.call(parts, '-');\r\n\r\n    // The steps laid out in RFC 5646 section 4.5 are as follows:\r\n\r\n    // 1.  Extension sequences are ordered into case-insensitive ASCII order\r\n    //     by singleton subtag.\r\n    if ((match = locale.match(expExtSequences)) && match.length > 1) {\r\n        // The built-in sort() sorts by ASCII order, so use that\r\n        match.sort();\r\n\r\n        // Replace all extensions with the joined, sorted array\r\n        locale = locale.replace(\r\n            RegExp('(?:' + expExtSequences.source + ')+', 'i'),\r\n            arrJoin.call(match, '')\r\n        );\r\n    }\r\n\r\n    // 2.  Redundant or grandfathered tags are replaced by their 'Preferred-\r\n    //     Value', if there is one.\r\n    if (hop.call(redundantTags.tags, locale))\r\n        locale = redundantTags.tags[locale];\r\n\r\n    // 3.  Subtags are replaced by their 'Preferred-Value', if there is one.\r\n    //     For extlangs, the original primary language subtag is also\r\n    //     replaced if there is a primary language subtag in the 'Preferred-\r\n    //     Value'.\r\n    parts = locale.split('-');\r\n\r\n    for (let i = 1, max = parts.length; i < max; i++) {\r\n        if (hop.call(redundantTags.subtags, parts[i]))\r\n            parts[i] = redundantTags.subtags[parts[i]];\r\n\r\n        else if (hop.call(redundantTags.extLang, parts[i])) {\r\n            parts[i] = redundantTags.extLang[parts[i]][0];\r\n\r\n            // For extlang tags, the prefix needs to be removed if it is redundant\r\n            if (i === 1 && redundantTags.extLang[parts[1]][1] === parts[0]) {\r\n                parts = arrSlice.call(parts, i++);\r\n                max -= 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    return arrJoin.call(parts, '-');\r\n}\r\n\r\n/**\r\n * The DefaultLocale abstract operation returns a String value representing the\r\n * structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the\r\n * host environment’s current locale.\r\n */\r\nexport function /* 6.2.4 */DefaultLocale () {\r\n    return defaultLocale;\r\n}\r\n\r\n// Sect 6.3 Currency Codes\r\n// =======================\r\n\r\nconst expCurrencyCode = /^[A-Z]{3}$/;\r\n\r\n/**\r\n * The IsWellFormedCurrencyCode abstract operation verifies that the currency argument\r\n * (after conversion to a String value) represents a well-formed 3-letter ISO currency\r\n * code. The following steps are taken:\r\n */\r\nexport function /* 6.3.1 */IsWellFormedCurrencyCode(currency) {\r\n    // 1. Let `c` be ToString(currency)\r\n    let c = String(currency);\r\n\r\n    // 2. Let `normalized` be the result of mapping c to upper case as described\r\n    //    in 6.1.\r\n    let normalized = toLatinUpperCase(c);\r\n\r\n    // 3. If the string length of normalized is not 3, return false.\r\n    // 4. If normalized contains any character that is not in the range \"A\" to \"Z\"\r\n    //    (U+0041 to U+005A), return false.\r\n    if (expCurrencyCode.test(normalized) === false)\r\n        return false;\r\n\r\n    // 5. Return true\r\n    return true;\r\n}\r\n","// Sect 9.2 Abstract Operations\r\n// ============================\r\n\r\nimport {\r\n    List,\r\n    toObject,\r\n    toLength,\r\n    arrIndexOf,\r\n    arrPush,\r\n    arrSlice,\r\n    Record,\r\n    hop,\r\n    defineProperty\r\n} from \"./util.js\";\r\n\r\nimport {\r\n    IsStructurallyValidLanguageTag,\r\n    CanonicalizeLanguageTag,\r\n    DefaultLocale\r\n} from \"./6.locales-currencies-tz.js\";\r\n\r\nconst expUnicodeExSeq = /-u(?:-[0-9a-z]{2,8})+/gi; // See `extension` below\r\n\r\nexport function /* 9.2.1 */CanonicalizeLocaleList (locales) {\r\n// The abstract operation CanonicalizeLocaleList takes the following steps:\r\n\r\n    // 1. If locales is undefined, then a. Return a new empty List\r\n    if (locales === undefined)\r\n        return new List();\r\n\r\n    // 2. Let seen be a new empty List.\r\n    let seen = new List();\r\n\r\n    // 3. If locales is a String value, then\r\n    //    a. Let locales be a new array created as if by the expression new\r\n    //    Array(locales) where Array is the standard built-in constructor with\r\n    //    that name and locales is the value of locales.\r\n    locales = typeof locales === 'string' ? [ locales ] : locales;\r\n\r\n    // 4. Let O be ToObject(locales).\r\n    let O = toObject(locales);\r\n\r\n    // 5. Let lenValue be the result of calling the [[Get]] internal method of\r\n    //    O with the argument \"length\".\r\n    // 6. Let len be ToUint32(lenValue).\r\n    let len = toLength(O.length);\r\n\r\n    // 7. Let k be 0.\r\n    let k = 0;\r\n\r\n    // 8. Repeat, while k < len\r\n    while (k < len) {\r\n        // a. Let Pk be ToString(k).\r\n        let Pk = String(k);\r\n\r\n        // b. Let kPresent be the result of calling the [[HasProperty]] internal\r\n        //    method of O with argument Pk.\r\n        let kPresent = Pk in O;\r\n\r\n        // c. If kPresent is true, then\r\n        if (kPresent) {\r\n            // i. Let kValue be the result of calling the [[Get]] internal\r\n            //     method of O with argument Pk.\r\n            let kValue = O[Pk];\r\n\r\n            // ii. If the type of kValue is not String or Object, then throw a\r\n            //     TypeError exception.\r\n            if (kValue === null || (typeof kValue !== 'string' && typeof kValue !== 'object'))\r\n                throw new TypeError('String or Object type expected');\r\n\r\n            // iii. Let tag be ToString(kValue).\r\n            let tag = String(kValue);\r\n\r\n            // iv. If the result of calling the abstract operation\r\n            //     IsStructurallyValidLanguageTag (defined in 6.2.2), passing tag as\r\n            //     the argument, is false, then throw a RangeError exception.\r\n            if (!IsStructurallyValidLanguageTag(tag))\r\n                throw new RangeError(\"'\" + tag + \"' is not a structurally valid language tag\");\r\n\r\n            // v. Let tag be the result of calling the abstract operation\r\n            //    CanonicalizeLanguageTag (defined in 6.2.3), passing tag as the\r\n            //    argument.\r\n            tag = CanonicalizeLanguageTag(tag);\r\n\r\n            // vi. If tag is not an element of seen, then append tag as the last\r\n            //     element of seen.\r\n            if (arrIndexOf.call(seen, tag) === -1)\r\n                arrPush.call(seen, tag);\r\n        }\r\n\r\n        // d. Increase k by 1.\r\n        k++;\r\n    }\r\n\r\n    // 9. Return seen.\r\n    return seen;\r\n}\r\n\r\n/**\r\n * The BestAvailableLocale abstract operation compares the provided argument\r\n * locale, which must be a String value with a structurally valid and\r\n * canonicalized BCP 47 language tag, against the locales in availableLocales and\r\n * returns either the longest non-empty prefix of locale that is an element of\r\n * availableLocales, or undefined if there is no such element. It uses the\r\n * fallback mechanism of RFC 4647, section 3.4. The following steps are taken:\r\n */\r\nexport function /* 9.2.2 */BestAvailableLocale (availableLocales, locale) {\r\n    // 1. Let candidate be locale\r\n    let candidate = locale;\r\n\r\n    // 2. Repeat\r\n    while (candidate) {\r\n        // a. If availableLocales contains an element equal to candidate, then return\r\n        // candidate.\r\n        if (arrIndexOf.call(availableLocales, candidate) > -1)\r\n            return candidate;\r\n\r\n        // b. Let pos be the character index of the last occurrence of \"-\"\r\n        // (U+002D) within candidate. If that character does not occur, return\r\n        // undefined.\r\n        let pos = candidate.lastIndexOf('-');\r\n\r\n        if (pos < 0)\r\n            return;\r\n\r\n        // c. If pos ≥ 2 and the character \"-\" occurs at index pos-2 of candidate,\r\n        //    then decrease pos by 2.\r\n        if (pos >= 2 && candidate.charAt(pos - 2) === '-')\r\n            pos -= 2;\r\n\r\n        // d. Let candidate be the substring of candidate from position 0, inclusive,\r\n        //    to position pos, exclusive.\r\n        candidate = candidate.substring(0, pos);\r\n    }\r\n}\r\n\r\n/**\r\n * The LookupMatcher abstract operation compares requestedLocales, which must be\r\n * a List as returned by CanonicalizeLocaleList, against the locales in\r\n * availableLocales and determines the best available language to meet the\r\n * request. The following steps are taken:\r\n */\r\nexport function /* 9.2.3 */LookupMatcher (availableLocales, requestedLocales) {\r\n    // 1. Let i be 0.\r\n    let i = 0;\r\n\r\n    // 2. Let len be the number of elements in requestedLocales.\r\n    let len = requestedLocales.length;\r\n\r\n    // 3. Let availableLocale be undefined.\r\n    let availableLocale;\r\n\r\n    let locale, noExtensionsLocale;\r\n\r\n    // 4. Repeat while i < len and availableLocale is undefined:\r\n    while (i < len && !availableLocale) {\r\n        // a. Let locale be the element of requestedLocales at 0-origined list\r\n        //    position i.\r\n        locale = requestedLocales[i];\r\n\r\n        // b. Let noExtensionsLocale be the String value that is locale with all\r\n        //    Unicode locale extension sequences removed.\r\n        noExtensionsLocale = String(locale).replace(expUnicodeExSeq, '');\r\n\r\n        // c. Let availableLocale be the result of calling the\r\n        //    BestAvailableLocale abstract operation (defined in 9.2.2) with\r\n        //    arguments availableLocales and noExtensionsLocale.\r\n        availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\r\n\r\n        // d. Increase i by 1.\r\n        i++;\r\n    }\r\n\r\n    // 5. Let result be a new Record.\r\n    let result = new Record();\r\n\r\n    // 6. If availableLocale is not undefined, then\r\n    if (availableLocale !== undefined) {\r\n        // a. Set result.[[locale]] to availableLocale.\r\n        result['[[locale]]'] = availableLocale;\r\n\r\n        // b. If locale and noExtensionsLocale are not the same String value, then\r\n        if (String(locale) !== String(noExtensionsLocale)) {\r\n            // i. Let extension be the String value consisting of the first\r\n            //    substring of locale that is a Unicode locale extension sequence.\r\n            let extension = locale.match(expUnicodeExSeq)[0];\r\n\r\n            // ii. Let extensionIndex be the character position of the initial\r\n            //     \"-\" of the first Unicode locale extension sequence within locale.\r\n            let extensionIndex = locale.indexOf('-u-');\r\n\r\n            // iii. Set result.[[extension]] to extension.\r\n            result['[[extension]]'] = extension;\r\n\r\n            // iv. Set result.[[extensionIndex]] to extensionIndex.\r\n            result['[[extensionIndex]]'] = extensionIndex;\r\n        }\r\n    }\r\n    // 7. Else\r\n    else\r\n        // a. Set result.[[locale]] to the value returned by the DefaultLocale abstract\r\n        //    operation (defined in 6.2.4).\r\n        result['[[locale]]'] = DefaultLocale();\r\n\r\n    // 8. Return result\r\n    return result;\r\n}\r\n\r\n/**\r\n * The BestFitMatcher abstract operation compares requestedLocales, which must be\r\n * a List as returned by CanonicalizeLocaleList, against the locales in\r\n * availableLocales and determines the best available language to meet the\r\n * request. The algorithm is implementation dependent, but should produce results\r\n * that a typical user of the requested locales would perceive as at least as\r\n * good as those produced by the LookupMatcher abstract operation. Options\r\n * specified through Unicode locale extension sequences must be ignored by the\r\n * algorithm. Information about such subsequences is returned separately.\r\n * The abstract operation returns a record with a [[locale]] field, whose value\r\n * is the language tag of the selected locale, which must be an element of\r\n * availableLocales. If the language tag of the request locale that led to the\r\n * selected locale contained a Unicode locale extension sequence, then the\r\n * returned record also contains an [[extension]] field whose value is the first\r\n * Unicode locale extension sequence, and an [[extensionIndex]] field whose value\r\n * is the index of the first Unicode locale extension sequence within the request\r\n * locale language tag.\r\n */\r\nexport function /* 9.2.4 */BestFitMatcher (availableLocales, requestedLocales) {\r\n    return LookupMatcher(availableLocales, requestedLocales);\r\n}\r\n\r\n// @spec[tc39/ecma402/master/spec/negotiation.html]\r\n// @clause[sec-unicodeextensionsubtags]\r\nexport function UnicodeExtensionSubtags(extension) {\r\n    // 1. Let size be the number of elements in extension.\r\n    let size = extension.length;\r\n    // 2. If size = 0, then\r\n    if (size === 0) {\r\n        // a. Return « ».\r\n        return [];\r\n    }\r\n    // 3. Let extensionSubtags be « ».\r\n    let extensionSubtags = [];\r\n    // 4. Let attribute be true.\r\n    let attribute = true;\r\n    // 5. Let q be 3.\r\n    let q = 3;\r\n    // 6. Let p be q.\r\n    let p = q;\r\n    // 7. Let t be q.\r\n    let t = q;\r\n    // 8. Repeat, while q < size\r\n    while (q < size) {\r\n        // a. Let c be the code unit value of the element at index q in the String extension.\r\n        let c = extension.codePointAt(q);\r\n        // a. If c is 0x002D (HYPHEN-MINUS), then\r\n        if (c === 0x002D) {\r\n            // i. If q - p = 2, then\r\n            if (q - p === 2) {\r\n                // 1. If p - t > 1, then\r\n                if (p - t > 1) {\r\n                    // a. Let type be a String value equal to the substring of extension consisting of the code units at indices t (inclusive) through p - 1 (exclusive).\r\n                    let type = extension.substring(t, p - 1);\r\n                    // a. Append type as the last element of extensionSubtags.\r\n                    extensionSubtags.push(type);\r\n                }\r\n                // 2. Let key be a String value equal to the substring of extension consisting of the code units at indices p (inclusive) through q (exclusive).\r\n                let key = extension.substring(p, q);\r\n                // 3. Append key as the last element of extensionSubtags.\r\n                extensionSubtags.push(key);\r\n                // 4. Let t be q + 1.\r\n                t = q + 1;\r\n                // 5. Let attribute be false.\r\n                attribute = false;\r\n            // ii. Else if attribute is true, then\r\n            } else if (attribute === true) {\r\n                // 1. Let attr be a String value equal to the substring of extension consisting of the code units at indices p (inclusive) through q (exclusive).\r\n                let attr = extension.substring(p, q);\r\n                // 2. Append attr as the last element of extensionSubtags.\r\n                extensionSubtags.push(attr);\r\n                // 3. Let t be q + 1.\r\n                t = q + 1;\r\n            }\r\n            // iii. Let p be q + 1.\r\n            p = q + 1;\r\n        }\r\n        // a. Let q be q + 1.\r\n        q = q + 1;\r\n    }\r\n    // 9. If size - p = 2, then\r\n    if (size - p === 2) {\r\n        // a. If p - t > 1, then\r\n        if (p - t > 1) {\r\n            // i. Let type be a String value equal to the substring of extension consisting of the code units at indices t (inclusive) through p - 1 (exclusive).\r\n            let type = extension.substring(t, p - 1);\r\n            // ii. Append type as the last element of extensionSubtags.\r\n            extensionSubtags.push(type);\r\n        }\r\n        // a. Let t be p.\r\n        t = p;\r\n    }\r\n    // 10. Let tail be a String value equal to the substring of extension consisting of the code units at indices t (inclusive) through size (exclusive).\r\n    let tail = extension.substring(t, size);\r\n    // 11. Append tail as the last element of extensionSubtags.\r\n    extensionSubtags.push(tail);\r\n    // 12. Return extensionSubtags.\r\n    return extensionSubtags;\r\n}\r\n\r\n/**\r\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\r\n * requestedLocales against the locales in availableLocales and determines the\r\n * best available language to meet the request. availableLocales and\r\n * requestedLocales must be provided as List values, options as a Record.\r\n */\r\nexport function /* 9.2.5 */ResolveLocale (availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {\r\n    if (availableLocales.length === 0) {\r\n        throw new ReferenceError('No locale data has been provided for this object yet.');\r\n    }\r\n\r\n    // The following steps are taken:\r\n    // 1. Let matcher be the value of options.[[localeMatcher]].\r\n    let matcher = options['[[localeMatcher]]'];\r\n\r\n    let r;\r\n\r\n    // 2. If matcher is \"lookup\", then\r\n    if (matcher === 'lookup')\r\n        // a. Let r be the result of calling the LookupMatcher abstract operation\r\n        //    (defined in 9.2.3) with arguments availableLocales and\r\n        //    requestedLocales.\r\n        r = LookupMatcher(availableLocales, requestedLocales);\r\n\r\n    // 3. Else\r\n    else\r\n        // a. Let r be the result of calling the BestFitMatcher abstract\r\n        //    operation (defined in 9.2.4) with arguments availableLocales and\r\n        //    requestedLocales.\r\n        r = BestFitMatcher(availableLocales, requestedLocales);\r\n\r\n    // 4. Let foundLocale be the value of r.[[locale]].\r\n    let foundLocale = r['[[locale]]'];\r\n\r\n    let extensionSubtags, extensionSubtagsLength;\r\n\r\n    // 5. If r has an [[extension]] field, then\r\n    if (hop.call(r, '[[extension]]')) {\r\n        // a. Let extension be the value of r.[[extension]].\r\n        let extension = r['[[extension]]'];\r\n        // b. Let _extensionSubtags_ be\r\n        // CreateArrayFromList(UnicodeExtensionSubtags(_extension_)).\r\n        extensionSubtags = UnicodeExtensionSubtags(extension);\r\n        // c. Let _extensionSubtagsLength_ be Get(_extensionSubtags_, *\"length\"*)\r\n        extensionSubtagsLength = extensionSubtags.length;\r\n    }\r\n\r\n    // 6. Let result be a new Record.\r\n    let result = new Record();\r\n\r\n    // 7. Set result.[[dataLocale]] to foundLocale.\r\n    result['[[dataLocale]]'] = foundLocale;\r\n\r\n    // 8. Let supportedExtension be \"-u\".\r\n    let supportedExtension = '-u';\r\n    // 9. Let i be 0.\r\n    let i = 0;\r\n    // 10. Let len be the result of calling the [[Get]] internal method of\r\n    //     relevantExtensionKeys with argument \"length\".\r\n    let len = relevantExtensionKeys.length;\r\n\r\n    // 11 Repeat while i < len:\r\n    while (i < len) {\r\n        // a. Let key be the result of calling the [[Get]] internal method of\r\n        //    relevantExtensionKeys with argument ToString(i).\r\n        let key = relevantExtensionKeys[i];\r\n        // b. Let foundLocaleData be the result of calling the [[Get]] internal\r\n        //    method of localeData with the argument foundLocale.\r\n        let foundLocaleData = localeData[foundLocale];\r\n        // c. Let keyLocaleData be the result of calling the [[Get]] internal\r\n        //    method of foundLocaleData with the argument key.\r\n        let keyLocaleData = foundLocaleData[key];\r\n        // d. Let value be the result of calling the [[Get]] internal method of\r\n        //    keyLocaleData with argument \"0\".\r\n        let value = keyLocaleData['0'];\r\n        // e. Let supportedExtensionAddition be \"\".\r\n        let supportedExtensionAddition = '';\r\n        // f. Let indexOf be the standard built-in function object defined in\r\n        //    ES5, 15.4.4.14.\r\n        let indexOf = arrIndexOf;\r\n\r\n        // g. If extensionSubtags is not undefined, then\r\n        if (extensionSubtags !== undefined) {\r\n            // i. Let keyPos be the result of calling the [[Call]] internal\r\n            //    method of indexOf with extensionSubtags as the this value and\r\n            // an argument list containing the single item key.\r\n            let keyPos = indexOf.call(extensionSubtags, key);\r\n\r\n            // ii. If keyPos ≠ -1, then\r\n            if (keyPos !== -1) {\r\n                // 1. If keyPos + 1 < extensionSubtagsLength and the length of the\r\n                //    result of calling the [[Get]] internal method of\r\n                //    extensionSubtags with argument ToString(keyPos +1) is greater\r\n                //    than 2, then\r\n                if (keyPos + 1 < extensionSubtagsLength\r\n                        && extensionSubtags[keyPos + 1].length > 2) {\r\n                    // a. Let requestedValue be the result of calling the [[Get]]\r\n                    //    internal method of extensionSubtags with argument\r\n                    //    ToString(keyPos + 1).\r\n                    let requestedValue = extensionSubtags[keyPos + 1];\r\n                    // b. Let valuePos be the result of calling the [[Call]]\r\n                    //    internal method of indexOf with keyLocaleData as the\r\n                    //    this value and an argument list containing the single\r\n                    //    item requestedValue.\r\n                    let valuePos = indexOf.call(keyLocaleData, requestedValue);\r\n\r\n                    // c. If valuePos ≠ -1, then\r\n                    if (valuePos !== -1) {\r\n                        // i. Let value be requestedValue.\r\n                        value = requestedValue,\r\n                        // ii. Let supportedExtensionAddition be the\r\n                        //     concatenation of \"-\", key, \"-\", and value.\r\n                        supportedExtensionAddition = '-' + key + '-' + value;\r\n                    }\r\n                }\r\n                // 2. Else\r\n                else {\r\n                    // a. Let valuePos be the result of calling the [[Call]]\r\n                    // internal method of indexOf with keyLocaleData as the this\r\n                    // value and an argument list containing the single item\r\n                    // \"true\".\r\n                    let valuePos = indexOf(keyLocaleData, 'true');\r\n\r\n                    // b. If valuePos ≠ -1, then\r\n                    if (valuePos !== -1)\r\n                        // i. Let value be \"true\".\r\n                        value = 'true';\r\n                }\r\n            }\r\n        }\r\n        // h. If options has a field [[<key>]], then\r\n        if (hop.call(options, '[[' + key + ']]')) {\r\n            // i. Let optionsValue be the value of options.[[<key>]].\r\n            let optionsValue = options['[[' + key + ']]'];\r\n\r\n            // ii. If the result of calling the [[Call]] internal method of indexOf\r\n            //     with keyLocaleData as the this value and an argument list\r\n            //     containing the single item optionsValue is not -1, then\r\n            if (indexOf.call(keyLocaleData, optionsValue) !== -1) {\r\n                // 1. If optionsValue is not equal to value, then\r\n                if (optionsValue !== value) {\r\n                    // a. Let value be optionsValue.\r\n                    value = optionsValue;\r\n                    // b. Let supportedExtensionAddition be \"\".\r\n                    supportedExtensionAddition = '';\r\n                }\r\n            }\r\n        }\r\n        // i. Set result.[[<key>]] to value.\r\n        result['[[' + key + ']]'] = value;\r\n\r\n        // j. Append supportedExtensionAddition to supportedExtension.\r\n        supportedExtension += supportedExtensionAddition;\r\n\r\n        // k. Increase i by 1.\r\n        i++;\r\n    }\r\n    // 12. If the length of supportedExtension is greater than 2, then\r\n    if (supportedExtension.length > 2) {\r\n        // a.\r\n        let privateIndex = foundLocale.indexOf(\"-x-\");\r\n        // b.\r\n        if (privateIndex === -1) {\r\n            // i.\r\n            foundLocale = foundLocale + supportedExtension;\r\n        }\r\n        // c.\r\n        else {\r\n            // i.\r\n            let preExtension = foundLocale.substring(0, privateIndex);\r\n            // ii.\r\n            let postExtension = foundLocale.substring(privateIndex);\r\n            // iii.\r\n            foundLocale = preExtension + supportedExtension + postExtension;\r\n        }\r\n        // d. asserting - skipping\r\n        // e.\r\n        foundLocale = CanonicalizeLanguageTag(foundLocale);\r\n    }\r\n    // 13. Set result.[[locale]] to foundLocale.\r\n    result['[[locale]]'] = foundLocale;\r\n\r\n    // 14. Return result.\r\n    return result;\r\n}\r\n\r\n/**\r\n * The LookupSupportedLocales abstract operation returns the subset of the\r\n * provided BCP 47 language priority list requestedLocales for which\r\n * availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\r\n * Locales appear in the same order in the returned list as in requestedLocales.\r\n * The following steps are taken:\r\n */\r\nexport function /* 9.2.6 */LookupSupportedLocales (availableLocales, requestedLocales) {\r\n    // 1. Let len be the number of elements in requestedLocales.\r\n    let len = requestedLocales.length;\r\n    // 2. Let subset be a new empty List.\r\n    let subset = new List();\r\n    // 3. Let k be 0.\r\n    let k = 0;\r\n\r\n    // 4. Repeat while k < len\r\n    while (k < len) {\r\n        // a. Let locale be the element of requestedLocales at 0-origined list\r\n        //    position k.\r\n        let locale = requestedLocales[k];\r\n        // b. Let noExtensionsLocale be the String value that is locale with all\r\n        //    Unicode locale extension sequences removed.\r\n        let noExtensionsLocale = String(locale).replace(expUnicodeExSeq, '');\r\n        // c. Let availableLocale be the result of calling the\r\n        //    BestAvailableLocale abstract operation (defined in 9.2.2) with\r\n        //    arguments availableLocales and noExtensionsLocale.\r\n        let availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\r\n\r\n        // d. If availableLocale is not undefined, then append locale to the end of\r\n        //    subset.\r\n        if (availableLocale !== undefined)\r\n            arrPush.call(subset, locale);\r\n\r\n        // e. Increment k by 1.\r\n        k++;\r\n    }\r\n\r\n    // 5. Let subsetArray be a new Array object whose elements are the same\r\n    //    values in the same order as the elements of subset.\r\n    let subsetArray = arrSlice.call(subset);\r\n\r\n    // 6. Return subsetArray.\r\n    return subsetArray;\r\n}\r\n\r\n/**\r\n * The BestFitSupportedLocales abstract operation returns the subset of the\r\n * provided BCP 47 language priority list requestedLocales for which\r\n * availableLocales has a matching locale when using the Best Fit Matcher\r\n * algorithm. Locales appear in the same order in the returned list as in\r\n * requestedLocales. The steps taken are implementation dependent.\r\n */\r\nexport function /*9.2.7 */BestFitSupportedLocales (availableLocales, requestedLocales) {\r\n    // ###TODO: implement this function as described by the specification###\r\n    return LookupSupportedLocales(availableLocales, requestedLocales);\r\n}\r\n\r\n/**\r\n * The SupportedLocales abstract operation returns the subset of the provided BCP\r\n * 47 language priority list requestedLocales for which availableLocales has a\r\n * matching locale. Two algorithms are available to match the locales: the Lookup\r\n * algorithm described in RFC 4647 section 3.4, and an implementation dependent\r\n * best-fit algorithm. Locales appear in the same order in the returned list as\r\n * in requestedLocales. The following steps are taken:\r\n */\r\nexport function /*9.2.8 */SupportedLocales (availableLocales, requestedLocales, options) {\r\n    let matcher, subset;\r\n\r\n    // 1. If options is not undefined, then\r\n    if (options !== undefined) {\r\n        // a. Let options be ToObject(options).\r\n        options = new Record(toObject(options));\r\n        // b. Let matcher be the result of calling the [[Get]] internal method of\r\n        //    options with argument \"localeMatcher\".\r\n        matcher = options.localeMatcher;\r\n\r\n        // c. If matcher is not undefined, then\r\n        if (matcher !== undefined) {\r\n            // i. Let matcher be ToString(matcher).\r\n            matcher = String(matcher);\r\n\r\n            // ii. If matcher is not \"lookup\" or \"best fit\", then throw a RangeError\r\n            //     exception.\r\n            if (matcher !== 'lookup' && matcher !== 'best fit')\r\n                throw new RangeError('matcher should be \"lookup\" or \"best fit\"');\r\n        }\r\n    }\r\n    // 2. If matcher is undefined or \"best fit\", then\r\n    if (matcher === undefined || matcher === 'best fit')\r\n        // a. Let subset be the result of calling the BestFitSupportedLocales\r\n        //    abstract operation (defined in 9.2.7) with arguments\r\n        //    availableLocales and requestedLocales.\r\n        subset = BestFitSupportedLocales(availableLocales, requestedLocales);\r\n    // 3. Else\r\n    else\r\n        // a. Let subset be the result of calling the LookupSupportedLocales\r\n        //    abstract operation (defined in 9.2.6) with arguments\r\n        //    availableLocales and requestedLocales.\r\n        subset = LookupSupportedLocales(availableLocales, requestedLocales);\r\n\r\n    // 4. For each named own property name P of subset,\r\n    for (let P in subset) {\r\n        if (!hop.call(subset, P))\r\n            continue;\r\n\r\n        // a. Let desc be the result of calling the [[GetOwnProperty]] internal\r\n        //    method of subset with P.\r\n        // b. Set desc.[[Writable]] to false.\r\n        // c. Set desc.[[Configurable]] to false.\r\n        // d. Call the [[DefineOwnProperty]] internal method of subset with P, desc,\r\n        //    and true as arguments.\r\n        defineProperty(subset, P, {\r\n            writable: false, configurable: false, value: subset[P]\r\n        });\r\n    }\r\n\r\n    // 5. repeat the above operation for the length property,\r\n    //    since length is not enumerable in a List.\r\n    //    This is by design as it matches the behavior of Array.\r\n    defineProperty(subset, 'length', {\r\n        writable: false, configurable: false, value: subset.length\r\n    });\r\n\r\n\r\n    // 6. Return subset\r\n    return subset;\r\n}\r\n\r\n/**\r\n * The GetOption abstract operation extracts the value of the property named\r\n * property from the provided options object, converts it to the required type,\r\n * checks whether it is one of a List of allowed values, and fills in a fallback\r\n * value if necessary.\r\n */\r\nexport function /*9.2.9 */GetOption (options, property, type, values, fallback) {\r\n    // 1. Let value be the result of calling the [[Get]] internal method of\r\n    //    options with argument property.\r\n    let value = options[property];\r\n\r\n    // 2. If value is not undefined, then\r\n    if (value !== undefined) {\r\n        // a. Assert: type is \"boolean\" or \"string\".\r\n        // b. If type is \"boolean\", then let value be ToBoolean(value).\r\n        // c. If type is \"string\", then let value be ToString(value).\r\n        value = type === 'boolean' ? Boolean(value)\r\n                  : (type === 'string' ? String(value) : value);\r\n\r\n        // d. If values is not undefined, then\r\n        if (values !== undefined) {\r\n            // i. If values does not contain an element equal to value, then throw a\r\n            //    RangeError exception.\r\n            if (arrIndexOf.call(values, value) === -1)\r\n                throw new RangeError(\"'\" + value + \"' is not an allowed value for `\" + property +'`');\r\n        }\r\n\r\n        // e. Return value.\r\n        return value;\r\n    }\r\n    // Else return fallback.\r\n    return fallback;\r\n}\r\n\r\n/**\r\n * The GetNumberOption abstract operation extracts a property value from the\r\n * provided options object, converts it to a Number value, checks whether it is\r\n * in the allowed range, and fills in a fallback value if necessary.\r\n */\r\nexport function /* 9.2.10 */GetNumberOption (options, property, minimum, maximum, fallback) {\r\n    // 1. Let value be the result of calling the [[Get]] internal method of\r\n    //    options with argument property.\r\n    let value = options[property];\r\n\r\n    // 2. If value is not undefined, then\r\n    if (value !== undefined) {\r\n        // a. Let value be ToNumber(value).\r\n        value = Number(value);\r\n\r\n        // b. If value is NaN or less than minimum or greater than maximum, throw a\r\n        //    RangeError exception.\r\n        if (isNaN(value) || value < minimum || value > maximum)\r\n            throw new RangeError('Value is not a number or outside accepted range');\r\n\r\n        // c. Return floor(value).\r\n        return Math.floor(value);\r\n    }\r\n    // 3. Else return fallback.\r\n    return fallback;\r\n}\r\n","import {\r\n    CanonicalizeLocaleList\r\n} from \"./9.negotiation.js\";\r\n\r\n// 8 The Intl Object\r\nexport const Intl = {};\r\n\r\n// 8.2 Function Properties of the Intl Object\r\n\r\n// 8.2.1\r\n// @spec[tc39/ecma402/master/spec/intl.html]\r\n// @clause[sec-intl.getcanonicallocales]\r\nfunction getCanonicalLocales (locales) {\r\n    // 1. Let ll be ? CanonicalizeLocaleList(locales).\r\n    let ll = CanonicalizeLocaleList(locales);\r\n    // 2. Return CreateArrayFromList(ll).\r\n    {\r\n        let result = [];\r\n\r\n        let len = ll.length;\r\n        let k = 0;\r\n\r\n        while (k < len) {\r\n            result[k] = ll[k];\r\n            k++;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Intl, 'getCanonicalLocales', {\r\n  enumerable: false,\r\n  configurable: true,\r\n  writable: true,\r\n  value: getCanonicalLocales\r\n});\r\n","// 11.1 The Intl.NumberFormat constructor\r\n// ======================================\r\n\r\nimport {\r\n    IsWellFormedCurrencyCode\r\n} from \"./6.locales-currencies-tz.js\";\r\n\r\nimport {\r\n    Intl\r\n} from \"./8.intl.js\";\r\n\r\nimport {\r\n    CanonicalizeLocaleList,\r\n    SupportedLocales,\r\n    ResolveLocale,\r\n    GetNumberOption,\r\n    GetOption\r\n} from \"./9.negotiation.js\";\r\n\r\nimport {\r\n    internals,\r\n    log10Floor,\r\n    List,\r\n    toObject,\r\n    arrPush,\r\n    arrJoin,\r\n    arrShift,\r\n    Record,\r\n    hop,\r\n    defineProperty,\r\n    es3,\r\n    fnBind,\r\n    getInternalProperties,\r\n    createRegExpRestore,\r\n    secret,\r\n    objCreate\r\n} from \"./util.js\";\r\n\r\n// Currency minor units output from get-4217 grunt task, formatted\r\nconst currencyMinorUnits = {\r\n    BHD: 3, BYR: 0, XOF: 0, BIF: 0, XAF: 0, CLF: 4, CLP: 0, KMF: 0, DJF: 0,\r\n    XPF: 0, GNF: 0, ISK: 0, IQD: 3, JPY: 0, JOD: 3, KRW: 0, KWD: 3, LYD: 3,\r\n    OMR: 3, PYG: 0, RWF: 0, TND: 3, UGX: 0, UYI: 0, VUV: 0, VND: 0\r\n};\r\n\r\n// Define the NumberFormat constructor internally so it cannot be tainted\r\nexport function NumberFormatConstructor () {\r\n    let locales = arguments[0];\r\n    let options = arguments[1];\r\n\r\n    if (!this || this === Intl) {\r\n        return new Intl.NumberFormat(locales, options);\r\n    }\r\n\r\n    return InitializeNumberFormat(toObject(this), locales, options);\r\n}\r\n\r\ndefineProperty(Intl, 'NumberFormat', {\r\n    configurable: true,\r\n    writable: true,\r\n    value: NumberFormatConstructor\r\n});\r\n\r\n// Must explicitly set prototypes as unwritable\r\ndefineProperty(Intl.NumberFormat, 'prototype', {\r\n    writable: false\r\n});\r\n\r\n/*\r\n * @spec[tc39/ecma402/master/spec/numberformat.html]\r\n * @clause[sec-setnumberformatdigitoptions]\r\n */\r\nexport function /*11.1.1 */SetNumberFormatDigitOptions (intlObj, options, mnfdDefault) {\r\n    // 1. Assert: Type(intlObj) is Object and intlObj.[[initializedIntlObject]] is true.\r\n\r\n    // 2. Assert: Type(options) is Object.\r\n\r\n    // 3. Assert: type(mnfdDefault) is Number.\r\n\r\n    // 4. Let mnid be ? GetNumberOption(options, \"minimumIntegerDigits,\", 1, 21, 1).\r\n    let mnid = GetNumberOption(options, 'minimumIntegerDigits', 1, 21, 1);\r\n\r\n    // 5. Let mnfd be ? GetNumberOption(options, \"minimumFractionDigits\", 0, 20, mnfdDefault).\r\n    let mnfd = GetNumberOption(options, 'minimumFractionDigits', 0, 20, mnfdDefault);\r\n\r\n    // 6. Let mxfd be ? GetNumberOption(options, \"maximumFractionDigits\", mnfd, 20).\r\n    let mxfd = GetNumberOption(options, 'maximumFractionDigits', mnfd, 20);\r\n\r\n    // 7. Let mnsd be ? Get(options, \"minimumSignificantDigits\").\r\n    let mnsd = options.minimumSignificantDigits;\r\n\r\n    // 8. Let mxsd be ? Get(options, \"maximumSignificantDigits\").\r\n    let mxsd = options.maximumSignificantDigits;\r\n\r\n    // 9. Set intlObj.[[minimumIntegerDigits]] to mnid.\r\n    intlObj['[[minimumIntegerDigits]]'] = mnid;\r\n\r\n    // 10. Set intlObj.[[minimumFractionDigits]] to mnfd.\r\n    intlObj['[[minimumFractionDigits]]'] = mnfd;\r\n\r\n    // 11. Set intlObj.[[maximumFractionDigits]] to mxfd.\r\n    intlObj['[[maximumFractionDigits]]'] = mxfd;\r\n\r\n    // 12. If mnsd is not undefined or mxsd is not undefined, then\r\n    if (mnsd !== undefined || mxsd !== undefined) {\r\n        // a. Let mnsd be ? GetNumberOption(options, \"minimumSignificantDigits\", 1, 21, 1).\r\n        mnsd = GetNumberOption(options, \"minimumSignificantDigits\", 1, 21, 1);\r\n\r\n        // b. Let mxsd be ? GetNumberOption(options, \"maximumSignificantDigits\", mnsd, 21, 21).\r\n        mxsd = GetNumberOption(options, \"maximumSignificantDigits\", mnsd, 21, 21);\r\n\r\n        // c. Set intlObj.[[minimumSignificantDigits]] to mnsd.\r\n        intlObj['[[minimumSignificantDigits]]'] = mnsd;\r\n\r\n        // d. Set intlObj.[[maximumSignificantDigits]] to mxsd.\r\n        intlObj['[[maximumSignificantDigits]]'] = mxsd;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * The abstract operation InitializeNumberFormat accepts the arguments\r\n * numberFormat (which must be an object), locales, and options. It initializes\r\n * numberFormat as a NumberFormat object.\r\n */\r\nexport function /*11.1.2 */InitializeNumberFormat (numberFormat, locales, options) {\r\n    // This will be a internal properties object if we're not already initialized\r\n    let internal = getInternalProperties(numberFormat);\r\n\r\n    // Create an object whose props can be used to restore the values of RegExp props\r\n    let regexpRestore = createRegExpRestore();\r\n\r\n    // 1. If numberFormat has an [[initializedIntlObject]] internal property with\r\n    // value true, throw a TypeError exception.\r\n    if (internal['[[initializedIntlObject]]'] === true)\r\n        throw new TypeError('`this` object has already been initialized as an Intl object');\r\n\r\n    // Need this to access the `internal` object\r\n    defineProperty(numberFormat, '__getInternalProperties', {\r\n        value: function () {\r\n            // NOTE: Non-standard, for internal use only\r\n            if (arguments[0] === secret)\r\n                return internal;\r\n        }\r\n    });\r\n\r\n    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\r\n    internal['[[initializedIntlObject]]'] = true;\r\n\r\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\r\n    //    abstract operation (defined in 9.2.1) with argument locales.\r\n    let requestedLocales = CanonicalizeLocaleList(locales);\r\n\r\n    // 4. If options is undefined, then\r\n    if (options === undefined)\r\n        // a. Let options be the result of creating a new object as if by the\r\n        // expression new Object() where Object is the standard built-in constructor\r\n        // with that name.\r\n        options = {};\r\n\r\n    // 5. Else\r\n    else\r\n        // a. Let options be ToObject(options).\r\n        options = toObject(options);\r\n\r\n    // 6. Let opt be a new Record.\r\n    let opt = new Record(),\r\n\r\n    // 7. Let matcher be the result of calling the GetOption abstract operation\r\n    //    (defined in 9.2.9) with the arguments options, \"localeMatcher\", \"string\",\r\n    //    a List containing the two String values \"lookup\" and \"best fit\", and\r\n    //    \"best fit\".\r\n        matcher =  GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\r\n\r\n    // 8. Set opt.[[localeMatcher]] to matcher.\r\n    opt['[[localeMatcher]]'] = matcher;\r\n\r\n    // 9. Let localeData be the value of the [[localeData]] internal property of\r\n    //     NumberFormat.\r\n    let localeData = internals.NumberFormat['[[localeData]]'];\r\n\r\n    // 10. Let r be the result of calling the ResolveLocale abstract operation\r\n    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\r\n    //     NumberFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\r\n    //     internal property of NumberFormat, and localeData.\r\n    let r = ResolveLocale(\r\n            internals.NumberFormat['[[availableLocales]]'], requestedLocales,\r\n            opt, internals.NumberFormat['[[relevantExtensionKeys]]'], localeData\r\n        );\r\n\r\n    // 11. Set the [[locale]] internal property of numberFormat to the value of\r\n    //     r.[[locale]].\r\n    internal['[[locale]]'] = r['[[locale]]'];\r\n\r\n    // 12. Set the [[numberingSystem]] internal property of numberFormat to the value\r\n    //     of r.[[nu]].\r\n    internal['[[numberingSystem]]'] = r['[[nu]]'];\r\n\r\n    // The specification doesn't tell us to do this, but it's helpful later on\r\n    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\r\n\r\n    // 13. Let dataLocale be the value of r.[[dataLocale]].\r\n    let dataLocale = r['[[dataLocale]]'];\r\n\r\n    // 14. Let s be the result of calling the GetOption abstract operation with the\r\n    //     arguments options, \"style\", \"string\", a List containing the three String\r\n    //     values \"decimal\", \"percent\", and \"currency\", and \"decimal\".\r\n    let s = GetOption(options, 'style', 'string', new List('decimal', 'percent', 'currency'), 'decimal');\r\n\r\n    // 15. Set the [[style]] internal property of numberFormat to s.\r\n    internal['[[style]]'] = s;\r\n\r\n    // 16. Let c be the result of calling the GetOption abstract operation with the\r\n    //     arguments options, \"currency\", \"string\", undefined, and undefined.\r\n    let c = GetOption(options, 'currency', 'string');\r\n\r\n    // 17. If c is not undefined and the result of calling the\r\n    //     IsWellFormedCurrencyCode abstract operation (defined in 6.3.1) with\r\n    //     argument c is false, then throw a RangeError exception.\r\n    if (c !== undefined && !IsWellFormedCurrencyCode(c))\r\n        throw new RangeError(\"'\" + c + \"' is not a valid currency code\");\r\n\r\n    // 18. If s is \"currency\" and c is undefined, throw a TypeError exception.\r\n    if (s === 'currency' && c === undefined)\r\n        throw new TypeError('Currency code is required when style is currency');\r\n\r\n    let cDigits;\r\n\r\n    // 19. If s is \"currency\", then\r\n    if (s === 'currency') {\r\n        // a. Let c be the result of converting c to upper case as specified in 6.1.\r\n        c = c.toUpperCase();\r\n\r\n        // b. Set the [[currency]] internal property of numberFormat to c.\r\n        internal['[[currency]]'] = c;\r\n\r\n        // c. Let cDigits be the result of calling the CurrencyDigits abstract\r\n        //    operation (defined below) with argument c.\r\n        cDigits = CurrencyDigits(c);\r\n    }\r\n\r\n    // 20. Let cd be the result of calling the GetOption abstract operation with the\r\n    //     arguments options, \"currencyDisplay\", \"string\", a List containing the\r\n    //     three String values \"code\", \"symbol\", and \"name\", and \"symbol\".\r\n    let cd = GetOption(options, 'currencyDisplay', 'string', new List('code', 'symbol', 'name'), 'symbol');\r\n\r\n    // 21. If s is \"currency\", then set the [[currencyDisplay]] internal property of\r\n    //     numberFormat to cd.\r\n    if (s === 'currency')\r\n        internal['[[currencyDisplay]]'] = cd;\r\n\r\n    // 22. If s is \"currency\", then\r\n    //     a. Let mnfdDefault be cDigits.\r\n    // 23. Else,\r\n    //     a. Let mnfdDefault be 0.\r\n    let mnfdDefault = s === \"currency\" ? cDigits : 0;\r\n\r\n    // 24. Perform ? SetNumberFormatDigitOptions(numberFormat, options, mnfdDefault).\r\n    SetNumberFormatDigitOptions(internal, options, mnfdDefault);\r\n\r\n    // 25. If numberFormat.[[maximumFractionDigits]] is undefined, then\r\n    if (internal['[[maximumFractionDigits]]'] === undefined) {\r\n        // a. If s is \"currency\", then\r\n        if (s === 'currency') {\r\n            // i. Set numberFormat.[[maximumFractionDigits]] to max(numberFormat.[[minimumFractionDigits]], cDigits).\r\n            internal['[[maximumFractionDigits]]'] = Math.max(internal['[[minimumFractionDigits]]'], cDigits);\r\n        // b. Else if s is \"percent\", then\r\n        } else if (s === 'percent') {\r\n            // i. Set numberFormat.[[maximumFractionDigits]] to max(numberFormat.[[minimumFractionDigits]], 0).\r\n            internal['[[maximumFractionDigits]]'] = Math.max(internal['[[minimumFractionDigits]]'], 0);\r\n        // c. Else,\r\n        } else {\r\n            // i. Set numberFormat.[[maximumFractionDigits]] to max(numberFormat.[[minimumFractionDigits]], 3).\r\n            internal['[[maximumFractionDigits]]'] = Math.max(internal['[[minimumFractionDigits]]'], 3);\r\n        }\r\n    }\r\n\r\n    // 26. Let g be the result of calling the GetOption abstract operation with the\r\n    //     arguments options, \"useGrouping\", \"boolean\", undefined, and true.\r\n    let g = GetOption(options, 'useGrouping', 'boolean', undefined, true);\r\n\r\n    // 27. Set the [[useGrouping]] internal property of numberFormat to g.\r\n    internal['[[useGrouping]]'] = g;\r\n\r\n    // 28. Let dataLocaleData be the result of calling the [[Get]] internal method of\r\n    //     localeData with argument dataLocale.\r\n    let dataLocaleData = localeData[dataLocale];\r\n\r\n    // 29. Let patterns be the result of calling the [[Get]] internal method of\r\n    //     dataLocaleData with argument \"patterns\".\r\n    let patterns = dataLocaleData.patterns;\r\n\r\n    // 30. Assert: patterns is an object (see 11.2.3)\r\n\r\n    // 31. Let stylePatterns be the result of calling the [[Get]] internal method of\r\n    //     patterns with argument s.\r\n    let stylePatterns = patterns[s];\r\n\r\n    // 32. Set the [[positivePattern]] internal property of numberFormat to the\r\n    //     result of calling the [[Get]] internal method of stylePatterns with the\r\n    //     argument \"positivePattern\".\r\n    internal['[[positivePattern]]'] = stylePatterns.positivePattern;\r\n\r\n    // 33. Set the [[negativePattern]] internal property of numberFormat to the\r\n    //     result of calling the [[Get]] internal method of stylePatterns with the\r\n    //     argument \"negativePattern\".\r\n    internal['[[negativePattern]]'] = stylePatterns.negativePattern;\r\n\r\n    // 34. Set the [[boundFormat]] internal property of numberFormat to undefined.\r\n    internal['[[boundFormat]]'] = undefined;\r\n\r\n    // 35. Set the [[initializedNumberFormat]] internal property of numberFormat to\r\n    //     true.\r\n    internal['[[initializedNumberFormat]]'] = true;\r\n\r\n    // In ES3, we need to pre-bind the format() function\r\n    if (es3)\r\n        numberFormat.format = GetFormatNumber.call(numberFormat);\r\n\r\n    // Restore the RegExp properties\r\n    regexpRestore();\r\n\r\n    // 36. Return the newly initialised object\r\n    return numberFormat;\r\n}\r\n\r\nfunction CurrencyDigits(currency) {\r\n    // When the CurrencyDigits abstract operation is called with an argument currency\r\n    // (which must be an upper case String value), the following steps are taken:\r\n\r\n    // 1. If the ISO 4217 currency and funds code list contains currency as an\r\n    // alphabetic code, then return the minor unit value corresponding to the\r\n    // currency from the list; else return 2.\r\n    return currencyMinorUnits[currency] !== undefined\r\n                ? currencyMinorUnits[currency]\r\n                : 2;\r\n}\r\n\r\n/* 11.2.3 */internals.NumberFormat = {\r\n    '[[availableLocales]]': [],\r\n    '[[relevantExtensionKeys]]': ['nu'],\r\n    '[[localeData]]': {}\r\n};\r\n\r\n/**\r\n * When the supportedLocalesOf method of Intl.NumberFormat is called, the\r\n * following steps are taken:\r\n */\r\n/* 11.2.2 */\r\ndefineProperty(Intl.NumberFormat, 'supportedLocalesOf', {\r\n    configurable: true,\r\n    writable: true,\r\n    value: fnBind.call(function (locales) {\r\n        // Bound functions only have the `this` value altered if being used as a constructor,\r\n        // this lets us imitate a native function that has no constructor\r\n        if (!hop.call(this, '[[availableLocales]]'))\r\n            throw new TypeError('supportedLocalesOf() is not a constructor');\r\n\r\n        // Create an object whose props can be used to restore the values of RegExp props\r\n        let regexpRestore = createRegExpRestore(),\r\n\r\n        // 1. If options is not provided, then let options be undefined.\r\n            options = arguments[1],\r\n\r\n        // 2. Let availableLocales be the value of the [[availableLocales]] internal\r\n        //    property of the standard built-in object that is the initial value of\r\n        //    Intl.NumberFormat.\r\n\r\n            availableLocales = this['[[availableLocales]]'],\r\n\r\n        // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\r\n        //    abstract operation (defined in 9.2.1) with argument locales.\r\n            requestedLocales = CanonicalizeLocaleList(locales);\r\n\r\n        // Restore the RegExp properties\r\n        regexpRestore();\r\n\r\n        // 4. Return the result of calling the SupportedLocales abstract operation\r\n        //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\r\n        //    and options.\r\n        return SupportedLocales(availableLocales, requestedLocales, options);\r\n    }, internals.NumberFormat)\r\n});\r\n\r\n/**\r\n * This named accessor property returns a function that formats a number\r\n * according to the effective locale and the formatting options of this\r\n * NumberFormat object.\r\n */\r\n/* 11.3.2 */defineProperty(Intl.NumberFormat.prototype, 'format', {\r\n    configurable: true,\r\n    get: GetFormatNumber\r\n});\r\n\r\nfunction GetFormatNumber() {\r\n        let internal = this !== null && typeof this === 'object' && getInternalProperties(this);\r\n\r\n        // Satisfy test 11.3_b\r\n        if (!internal || !internal['[[initializedNumberFormat]]'])\r\n            throw new TypeError('`this` value for format() is not an initialized Intl.NumberFormat object.');\r\n\r\n        // The value of the [[Get]] attribute is a function that takes the following\r\n        // steps:\r\n\r\n        // 1. If the [[boundFormat]] internal property of this NumberFormat object\r\n        //    is undefined, then:\r\n        if (internal['[[boundFormat]]'] === undefined) {\r\n            // a. Let F be a Function object, with internal properties set as\r\n            //    specified for built-in functions in ES5, 15, or successor, and the\r\n            //    length property set to 1, that takes the argument value and\r\n            //    performs the following steps:\r\n            let F = function (value) {\r\n                // i. If value is not provided, then let value be undefined.\r\n                // ii. Let x be ToNumber(value).\r\n                // iii. Return the result of calling the FormatNumber abstract\r\n                //      operation (defined below) with arguments this and x.\r\n                return FormatNumber(this, /* x = */Number(value));\r\n            };\r\n\r\n            // b. Let bind be the standard built-in function object defined in ES5,\r\n            //    15.3.4.5.\r\n            // c. Let bf be the result of calling the [[Call]] internal method of\r\n            //    bind with F as the this value and an argument list containing\r\n            //    the single item this.\r\n            let bf = fnBind.call(F, this);\r\n\r\n            // d. Set the [[boundFormat]] internal property of this NumberFormat\r\n            //    object to bf.\r\n            internal['[[boundFormat]]'] = bf;\r\n        }\r\n        // Return the value of the [[boundFormat]] internal property of this\r\n        // NumberFormat object.\r\n        return internal['[[boundFormat]]'];\r\n    }\r\n\r\nfunction formatToParts(value = undefined) {\r\n  let internal = this !== null && typeof this === 'object' && getInternalProperties(this);\r\n  if (!internal || !internal['[[initializedNumberFormat]]'])\r\n      throw new TypeError('`this` value for formatToParts() is not an initialized Intl.NumberFormat object.');\r\n\r\n  let x = Number(value);\r\n  return FormatNumberToParts(this, x);\r\n}\r\n\r\nObject.defineProperty(Intl.NumberFormat.prototype, 'formatToParts', {\r\n  configurable: true,\r\n  enumerable: false,\r\n  writable: true,\r\n  value: formatToParts\r\n});\r\n\r\n/*\r\n * @spec[tc39/ecma402/master/spec/numberformat.html]\r\n * @clause[sec-formatnumbertoparts]\r\n */\r\nfunction FormatNumberToParts(numberFormat, x) {\r\n    // 1. Let parts be ? PartitionNumberPattern(numberFormat, x).\r\n    let parts = PartitionNumberPattern(numberFormat, x);\r\n    // 2. Let result be ArrayCreate(0).\r\n    let result = [];\r\n    // 3. Let n be 0.\r\n    let n = 0;\r\n    // 4. For each part in parts, do:\r\n    for (let i = 0; parts.length > i; i++) {\r\n        let part = parts[i];\r\n        // a. Let O be ObjectCreate(%ObjectPrototype%).\r\n        let O = {};\r\n        // a. Perform ? CreateDataPropertyOrThrow(O, \"type\", part.[[type]]).\r\n        O.type = part['[[type]]'];\r\n        // a. Perform ? CreateDataPropertyOrThrow(O, \"value\", part.[[value]]).\r\n        O.value = part['[[value]]'];\r\n        // a. Perform ? CreateDataPropertyOrThrow(result, ? ToString(n), O).\r\n        result[n] = O;\r\n        // a. Increment n by 1.\r\n        n += 1;\r\n    }\r\n    // 5. Return result.\r\n    return result;\r\n}\r\n\r\n/*\r\n * @spec[tc39/ecma402/master/spec/numberformat.html]\r\n * @clause[sec-formatnumberstring]\r\n */\r\nexport function FormatNumberToString(numberFormat, x) {\r\n    let internal = getInternalProperties(numberFormat);\r\n    let result;\r\n\r\n    // 1. Assert: numberFormat.[[initializedIntlObject]] is true.\r\n\r\n    // 2. If the numberFormat.[[minimumSignificantDigits]] and numberFormat.[[maximumSignificantDigits]] are present, then\r\n    if (hop.call(internal, '[[minimumSignificantDigits]]') &&\r\n        hop.call(internal, '[[maximumSignificantDigits]]')) {\r\n        // a. Let result be ToRawPrecision(x, numberFormat.[[minimumSignificantDigits]], numberFormat.[[maximumSignificantDigits]]).\r\n        result = ToRawPrecision(x,\r\n          internal['[[minimumSignificantDigits]]'],\r\n          internal['[[maximumSignificantDigits]]']);\r\n    }\r\n    // 3. Else,\r\n    else {\r\n        // a. Let result be ToRawFixed(x, numberFormat.[[minimumIntegerDigits]], numberFormat.[[minimumFractionDigits]], numberFormat.[[maximumFractionDigits]]).\r\n        result = ToRawFixed(x,\r\n          internal['[[minimumIntegerDigits]]'],\r\n          internal['[[minimumFractionDigits]]'],\r\n          internal['[[maximumFractionDigits]]']);\r\n    }\r\n    // 4. Return result.\r\n    return result;\r\n}\r\n\r\n/*\r\n * @spec[tc39/ecma402/master/spec/numberformat.html]\r\n * @clause[sec-partitionnumberpattern]\r\n */\r\nfunction PartitionNumberPattern(numberFormat, x) {\r\n\r\n    let internal = getInternalProperties(numberFormat),\r\n        locale = internal['[[dataLocale]]'],\r\n        nums = internal['[[numberingSystem]]'],\r\n        data = internals.NumberFormat['[[localeData]]'][locale],\r\n        ild = data.symbols[nums] || data.symbols.latn,\r\n        pattern;\r\n\r\n    // 1. If x is not NaN and x < 0, then:\r\n    if (!isNaN(x) && x < 0) {\r\n        // a. Let x be -x.\r\n        x = -x;\r\n        // b. Let pattern be the value of numberFormat.[[negativePattern]].\r\n        pattern = internal['[[negativePattern]]'];\r\n    }\r\n    // 2. Else,\r\n    else {\r\n        // a. Let pattern be the value of numberFormat.[[positivePattern]].\r\n        pattern = internal['[[positivePattern]]'];\r\n    }\r\n    // 3. Let result be a new empty List.\r\n    let result = new List();\r\n    // 4. Let beginIndex be Call(%StringProto_indexOf%, pattern, \"{\", 0).\r\n    let beginIndex = pattern.indexOf('{', 0);\r\n    // 5. Let endIndex be 0.\r\n    let endIndex = 0;\r\n    // 6. Let nextIndex be 0.\r\n    let nextIndex = 0;\r\n    // 7. Let length be the number of code units in pattern.\r\n    let length = pattern.length;\r\n    // 8. Repeat while beginIndex is an integer index into pattern:\r\n    while (beginIndex > -1 && beginIndex < length) {\r\n        // a. Set endIndex to Call(%StringProto_indexOf%, pattern, \"}\", beginIndex)\r\n        endIndex = pattern.indexOf('}', beginIndex);\r\n        // b. If endIndex = -1, throw new Error exception.\r\n        if (endIndex === -1) throw new Error();\r\n        // c. If beginIndex is greater than nextIndex, then:\r\n        if (beginIndex > nextIndex) {\r\n            // i. Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive.\r\n            let literal = pattern.substring(nextIndex, beginIndex);\r\n            // ii. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\r\n            arrPush.call(result, { '[[type]]': 'literal', '[[value]]': literal });\r\n        }\r\n        // d. Let p be the substring of pattern from position beginIndex, exclusive, to position endIndex, exclusive.\r\n        let p = pattern.substring(beginIndex + 1, endIndex);\r\n        // e. If p is equal \"number\", then:\r\n        if (p === \"number\") {\r\n            // i. If x is NaN,\r\n            if (isNaN(x)) {\r\n                // 1. Let n be an ILD String value indicating the NaN value.\r\n                let n = ild.nan;\r\n                // 2. Add new part record { [[type]]: \"nan\", [[value]]: n } as a new element of the list result.\r\n                arrPush.call(result, { '[[type]]': 'nan', '[[value]]': n });\r\n            }\r\n            // ii. Else if isFinite(x) is false,\r\n            else if (!isFinite(x)) {\r\n                // 1. Let n be an ILD String value indicating infinity.\r\n                let n = ild.infinity;\r\n                // 2. Add new part record { [[type]]: \"infinity\", [[value]]: n } as a new element of the list result.\r\n                arrPush.call(result, { '[[type]]': 'infinity', '[[value]]': n });\r\n            }\r\n            // iii. Else,\r\n            else {\r\n                // 1. If numberFormat.[[style]] is \"percent\", let x be 100 × x.\r\n                if (internal['[[style]]'] === 'percent') x *= 100;\r\n\r\n                // 2. Let n be FormatNumberToString(numberFormat, x).\r\n                let n = FormatNumberToString(numberFormat, x);\r\n\r\n                // 3. If the numberFormat.[[numberingSystem]] matches one of the values in the \"Numbering System\" column of Table 3 below, then\r\n                if (numSys[nums]) {\r\n                    // a. Let digits be an array whose 10 String valued elements are the UTF-16 string representations of the 10 digits specified in the \"Digits\" column of the matching row in Table 2.\r\n                    let digits = numSys[nums];\r\n                    // a. Replace each digit in n with the value of digits[digit].\r\n                    n = String(n).replace(/\\d/g, (digit) => {\r\n                        return digits[digit];\r\n                    });\r\n                }\r\n                // 4. Else use an implementation dependent algorithm to map n to the appropriate representation of n in the given numbering system.\r\n                else n = String(n); // ###TODO###\r\n\r\n                let integer;\r\n                let fraction;\r\n                // 5. Let decimalSepIndex be Call(%StringProto_indexOf%, n, \".\", 0).\r\n                let decimalSepIndex = n.indexOf('.', 0);\r\n                // 6. If decimalSepIndex > 0, then:\r\n                if (decimalSepIndex > 0) {\r\n                    // a. Let integer be the substring of n from position 0, inclusive, to position decimalSepIndex, exclusive.\r\n                    integer = n.substring(0, decimalSepIndex);\r\n                    // b. Let fraction be the substring of n from position decimalSepIndex, exclusive, to the end of n.\r\n                    fraction = n.substring(decimalSepIndex + 1, decimalSepIndex.length);\r\n                }\r\n                // 7. Else:\r\n                else {\r\n                    // a. Let integer be n.\r\n                    integer = n;\r\n                    // b. Let fraction be undefined.\r\n                    fraction = undefined;\r\n                }\r\n                // 8. If the value of the numberFormat.[[useGrouping]] is true,\r\n                if (internal['[[useGrouping]]'] === true) {\r\n                    // a. Let groupSepSymbol be the ILND String representing the grouping separator.\r\n                    let groupSepSymbol = ild.group;\r\n                    // b. Let groups be a List whose elements are, in left to right order, the substrings defined by ILND set of locations within the integer.\r\n                    let groups = [];\r\n                    // ----> implementation:\r\n                    // Primary group represents the group closest to the decimal\r\n                    let pgSize = data.patterns.primaryGroupSize || 3;\r\n                    // Secondary group is every other group\r\n                    let sgSize = data.patterns.secondaryGroupSize || pgSize;\r\n                    // Group only if necessary\r\n                    if (integer.length > pgSize) {\r\n                        // Index of the primary grouping separator\r\n                        let end = integer.length - pgSize;\r\n                        // Starting index for our loop\r\n                        let idx = end % sgSize;\r\n                        let start = integer.slice(0, idx);\r\n                        if (start.length) arrPush.call(groups, start);\r\n                        // Loop to separate into secondary grouping digits\r\n                        while (idx < end) {\r\n                            arrPush.call(groups, integer.slice(idx, idx + sgSize));\r\n                            idx += sgSize;\r\n                        }\r\n                        // Add the primary grouping digits\r\n                        arrPush.call(groups, integer.slice(end));\r\n                    } else {\r\n                        arrPush.call(groups, integer);\r\n                    }\r\n                    // c. Assert: The number of elements in groups List is greater than 0.\r\n                    if (groups.length === 0) throw new Error();\r\n                    // d. Repeat, while groups List is not empty:\r\n                    while (groups.length) {\r\n                        // i. Remove the first element from groups and let integerGroup be the value of that element.\r\n                        let integerGroup = arrShift.call(groups);\r\n                        // ii. Add new part record { [[type]]: \"integer\", [[value]]: integerGroup } as a new element of the list result.\r\n                        arrPush.call(result, { '[[type]]': 'integer', '[[value]]': integerGroup });\r\n                        // iii. If groups List is not empty, then:\r\n                        if (groups.length) {\r\n                            // 1. Add new part record { [[type]]: \"group\", [[value]]: groupSepSymbol } as a new element of the list result.\r\n                            arrPush.call(result, { '[[type]]': 'group', '[[value]]': groupSepSymbol });\r\n                        }\r\n                    }\r\n                }\r\n                // 9. Else,\r\n                else {\r\n                    // a. Add new part record { [[type]]: \"integer\", [[value]]: integer } as a new element of the list result.\r\n                    arrPush.call(result, { '[[type]]': 'integer', '[[value]]': integer });\r\n                }\r\n                // 10. If fraction is not undefined, then:\r\n                if (fraction !== undefined) {\r\n                    // a. Let decimalSepSymbol be the ILND String representing the decimal separator.\r\n                    let decimalSepSymbol = ild.decimal;\r\n                    // b. Add new part record { [[type]]: \"decimal\", [[value]]: decimalSepSymbol } as a new element of the list result.\r\n                    arrPush.call(result, { '[[type]]': 'decimal', '[[value]]': decimalSepSymbol });\r\n                    // c. Add new part record { [[type]]: \"fraction\", [[value]]: fraction } as a new element of the list result.\r\n                    arrPush.call(result, { '[[type]]': 'fraction', '[[value]]': fraction });\r\n                }\r\n            }\r\n        }\r\n        // f. Else if p is equal \"plusSign\", then:\r\n        else if (p === \"plusSign\") {\r\n            // i. Let plusSignSymbol be the ILND String representing the plus sign.\r\n            let plusSignSymbol = ild.plusSign;\r\n            // ii. Add new part record { [[type]]: \"plusSign\", [[value]]: plusSignSymbol } as a new element of the list result.\r\n            arrPush.call(result, { '[[type]]': 'plusSign', '[[value]]': plusSignSymbol });\r\n        }\r\n        // g. Else if p is equal \"minusSign\", then:\r\n        else if (p === \"minusSign\") {\r\n            // i. Let minusSignSymbol be the ILND String representing the minus sign.\r\n            let minusSignSymbol = ild.minusSign;\r\n            // ii. Add new part record { [[type]]: \"minusSign\", [[value]]: minusSignSymbol } as a new element of the list result.\r\n            arrPush.call(result, { '[[type]]': 'minusSign', '[[value]]': minusSignSymbol });\r\n        }\r\n        // h. Else if p is equal \"percentSign\" and numberFormat.[[style]] is \"percent\", then:\r\n        else if (p === \"percentSign\" && internal['[[style]]'] === \"percent\") {\r\n            // i. Let percentSignSymbol be the ILND String representing the percent sign.\r\n            let percentSignSymbol = ild.percentSign;\r\n            // ii. Add new part record { [[type]]: \"percentSign\", [[value]]: percentSignSymbol } as a new element of the list result.\r\n            arrPush.call(result, { '[[type]]': 'literal', '[[value]]': percentSignSymbol });\r\n        }\r\n        // i. Else if p is equal \"currency\" and numberFormat.[[style]] is \"currency\", then:\r\n        else if (p === \"currency\" && internal['[[style]]'] === \"currency\") {\r\n            // i. Let currency be the value of numberFormat.[[currency]].\r\n            let currency = internal['[[currency]]'];\r\n\r\n            let cd;\r\n\r\n            // iii. If numberFormat.[[currencyDisplay]] is \"code\", then\r\n            if (internal['[[currencyDisplay]]'] === \"code\") {\r\n                // 1. Let cd be currency.\r\n                cd = currency;\r\n            }\r\n            // iv. Else if numberFormat.[[currencyDisplay]] is \"symbol\", then\r\n            else if (internal['[[currencyDisplay]]'] === \"symbol\") {\r\n                // 1. Let cd be an ILD string representing currency in short form. If the implementation does not have such a representation of currency, use currency itself.\r\n                cd = data.currencies[currency] || currency;\r\n            }\r\n            // v. Else if numberFormat.[[currencyDisplay]] is \"name\", then\r\n            else if (internal['[[currencyDisplay]]'] === \"name\") {\r\n                // 1. Let cd be an ILD string representing currency in long form. If the implementation does not have such a representation of currency, then use currency itself.\r\n                cd = currency;\r\n            }\r\n            // vi. Add new part record { [[type]]: \"currency\", [[value]]: cd } as a new element of the list result.\r\n            arrPush.call(result, { '[[type]]': 'currency', '[[value]]': cd });\r\n        }\r\n        // j. Else,\r\n        else {\r\n          // i. Let literal be the substring of pattern from position beginIndex, inclusive, to position endIndex, inclusive.\r\n          let literal = pattern.substring(beginIndex, endIndex);\r\n          // ii. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\r\n          arrPush.call(result, { '[[type]]': 'literal', '[[value]]': literal });\r\n        }\r\n        // k. Set nextIndex to endIndex + 1.\r\n        nextIndex = endIndex + 1;\r\n        // l. Set beginIndex to Call(%StringProto_indexOf%, pattern, \"{\", nextIndex)\r\n        beginIndex = pattern.indexOf('{', nextIndex);\r\n    }\r\n    // 9. If nextIndex is less than length, then:\r\n    if (nextIndex < length) {\r\n        // a. Let literal be the substring of pattern from position nextIndex, inclusive, to position length, exclusive.\r\n        let literal = pattern.substring(nextIndex, length);\r\n        // b. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\r\n        arrPush.call(result, { '[[type]]': 'literal', '[[value]]': literal });\r\n    }\r\n    // 10. Return result.\r\n    return result;\r\n}\r\n\r\n/*\r\n * @spec[tc39/ecma402/master/spec/numberformat.html]\r\n * @clause[sec-formatnumber]\r\n */\r\nexport function FormatNumber(numberFormat, x) {\r\n    // 1. Let parts be ? PartitionNumberPattern(numberFormat, x).\r\n    let parts = PartitionNumberPattern(numberFormat, x);\r\n    // 2. Let result be an empty String.\r\n    let result = '';\r\n    // 3. For each part in parts, do:\r\n    for (let i = 0; parts.length > i; i++) {\r\n        let part = parts[i];\r\n        // a. Set result to a String value produced by concatenating result and part.[[value]].\r\n        result += part['[[value]]'];\r\n    }\r\n    // 4. Return result.\r\n    return result;\r\n}\r\n\r\n/**\r\n * When the ToRawPrecision abstract operation is called with arguments x (which\r\n * must be a finite non-negative number), minPrecision, and maxPrecision (both\r\n * must be integers between 1 and 21) the following steps are taken:\r\n */\r\nfunction ToRawPrecision (x, minPrecision, maxPrecision) {\r\n    // 1. Let p be maxPrecision.\r\n    let p = maxPrecision;\r\n\r\n    let m, e;\r\n\r\n    // 2. If x = 0, then\r\n    if (x === 0) {\r\n        // a. Let m be the String consisting of p occurrences of the character \"0\".\r\n        m = arrJoin.call(Array (p + 1), '0');\r\n        // b. Let e be 0.\r\n        e = 0;\r\n    }\r\n    // 3. Else\r\n    else {\r\n        // a. Let e and n be integers such that 10ᵖ⁻¹ ≤ n < 10ᵖ and for which the\r\n        //    exact mathematical value of n × 10ᵉ⁻ᵖ⁺¹ – x is as close to zero as\r\n        //    possible. If there are two such sets of e and n, pick the e and n for\r\n        //    which n × 10ᵉ⁻ᵖ⁺¹ is larger.\r\n        e = log10Floor(Math.abs(x));\r\n\r\n        // Easier to get to m from here\r\n        let f = Math.round(Math.exp((Math.abs(e - p + 1)) * Math.LN10));\r\n\r\n        // b. Let m be the String consisting of the digits of the decimal\r\n        //    representation of n (in order, with no leading zeroes)\r\n        m = String(Math.round(e - p + 1 < 0 ? x * f : x / f));\r\n    }\r\n\r\n    // 4. If e ≥ p, then\r\n    if (e >= p)\r\n        // a. Return the concatenation of m and e-p+1 occurrences of the character \"0\".\r\n        return m + arrJoin.call(Array(e-p+1 + 1), '0');\r\n\r\n    // 5. If e = p-1, then\r\n    else if (e === p - 1)\r\n        // a. Return m.\r\n        return m;\r\n\r\n    // 6. If e ≥ 0, then\r\n    else if (e >= 0)\r\n        // a. Let m be the concatenation of the first e+1 characters of m, the character\r\n        //    \".\", and the remaining p–(e+1) characters of m.\r\n        m = m.slice(0, e + 1) + '.' + m.slice(e + 1);\r\n\r\n    // 7. If e < 0, then\r\n    else if (e < 0)\r\n        // a. Let m be the concatenation of the String \"0.\", –(e+1) occurrences of the\r\n        //    character \"0\", and the string m.\r\n        m = '0.' + arrJoin.call(Array (-(e+1) + 1), '0') + m;\r\n\r\n    // 8. If m contains the character \".\", and maxPrecision > minPrecision, then\r\n    if (m.indexOf(\".\") >= 0 && maxPrecision > minPrecision) {\r\n        // a. Let cut be maxPrecision – minPrecision.\r\n        let cut = maxPrecision - minPrecision;\r\n\r\n        // b. Repeat while cut > 0 and the last character of m is \"0\":\r\n        while (cut > 0 && m.charAt(m.length-1) === '0') {\r\n            //  i. Remove the last character from m.\r\n            m = m.slice(0, -1);\r\n\r\n            //  ii. Decrease cut by 1.\r\n            cut--;\r\n        }\r\n\r\n        // c. If the last character of m is \".\", then\r\n        if (m.charAt(m.length-1) === '.')\r\n            //    i. Remove the last character from m.\r\n            m = m.slice(0, -1);\r\n    }\r\n    // 9. Return m.\r\n    return m;\r\n}\r\n\r\n/**\r\n * @spec[tc39/ecma402/master/spec/numberformat.html]\r\n * @clause[sec-torawfixed]\r\n * When the ToRawFixed abstract operation is called with arguments x (which must\r\n * be a finite non-negative number), minInteger (which must be an integer between\r\n * 1 and 21), minFraction, and maxFraction (which must be integers between 0 and\r\n * 20) the following steps are taken:\r\n */\r\nfunction ToRawFixed(x, minInteger, minFraction, maxFraction) {\r\n    // 1. Let f be maxFraction.\r\n    let f = maxFraction;\r\n    // 2. Let n be an integer for which the exact mathematical value of n ÷ 10f – x is as close to zero as possible. If there are two such n, pick the larger n.\r\n    let n = Math.pow(10, f) * x; // diverging...\r\n    // 3. If n = 0, let m be the String \"0\". Otherwise, let m be the String consisting of the digits of the decimal representation of n (in order, with no leading zeroes).\r\n    let m = (n === 0 ? \"0\" : n.toFixed(0)); // divering...\r\n\r\n    {\r\n        // this diversion is needed to take into consideration big numbers, e.g.:\r\n        // 1.2344501e+37 -> 12344501000000000000000000000000000000\r\n        let idx;\r\n        let exp = (idx = m.indexOf('e')) > -1 ? m.slice(idx + 1) : 0;\r\n        if (exp) {\r\n            m = m.slice(0, idx).replace('.', '');\r\n            m += arrJoin.call(Array(exp - (m.length - 1) + 1), '0');\r\n        }\r\n    }\r\n\r\n    let int;\r\n    // 4. If f ≠ 0, then\r\n    if (f !== 0) {\r\n        // a. Let k be the number of characters in m.\r\n        let k = m.length;\r\n        // a. If k ≤ f, then\r\n        if (k <= f) {\r\n            // i. Let z be the String consisting of f+1–k occurrences of the character \"0\".\r\n            let z = arrJoin.call(Array(f + 1 - k + 1), '0');\r\n            // ii. Let m be the concatenation of Strings z and m.\r\n            m = z + m;\r\n            // iii. Let k be f+1.\r\n            k = f + 1;\r\n        }\r\n        // a. Let a be the first k–f characters of m, and let b be the remaining f characters of m.\r\n        let a = m.substring(0, k - f), b = m.substring(k - f, m.length);\r\n        // a. Let m be the concatenation of the three Strings a, \".\", and b.\r\n        m = a + \".\" + b;\r\n        // a. Let int be the number of characters in a.\r\n        int = a.length;\r\n    }\r\n    // 5. Else, let int be the number of characters in m.\r\n    else int = m.length;\r\n    // 6. Let cut be maxFraction – minFraction.\r\n    let cut = maxFraction - minFraction;\r\n    // 7. Repeat while cut > 0 and the last character of m is \"0\":\r\n    while (cut > 0 && m.slice(-1) === \"0\") {\r\n        // a. Remove the last character from m.\r\n        m = m.slice(0, -1);\r\n        // a. Decrease cut by 1.\r\n        cut--;\r\n    }\r\n    // 8. If the last character of m is \".\", then\r\n    if (m.slice(-1) === \".\") {\r\n        // a. Remove the last character from m.\r\n        m = m.slice(0, -1);\r\n    }\r\n    // 9. If int < minInteger, then\r\n    if (int < minInteger) {\r\n        // a. Let z be the String consisting of minInteger–int occurrences of the character \"0\".\r\n        let z = arrJoin.call(Array(minInteger - int + 1), '0');\r\n        // a. Let m be the concatenation of Strings z and m.\r\n        m = z + m;\r\n    }\r\n    // 10. Return m.\r\n    return m;\r\n}\r\n\r\n// Sect 11.3.2 Table 2, Numbering systems\r\n// ======================================\r\nlet numSys = {\r\n    arab: ['\\u0660', '\\u0661', '\\u0662', '\\u0663', '\\u0664', '\\u0665', '\\u0666', '\\u0667', '\\u0668', '\\u0669'],\r\n    arabext: ['\\u06F0', '\\u06F1', '\\u06F2', '\\u06F3', '\\u06F4', '\\u06F5', '\\u06F6', '\\u06F7', '\\u06F8', '\\u06F9'],\r\n    bali: ['\\u1B50', '\\u1B51', '\\u1B52', '\\u1B53', '\\u1B54', '\\u1B55', '\\u1B56', '\\u1B57', '\\u1B58', '\\u1B59'],\r\n    beng: ['\\u09E6', '\\u09E7', '\\u09E8', '\\u09E9', '\\u09EA', '\\u09EB', '\\u09EC', '\\u09ED', '\\u09EE', '\\u09EF'],\r\n    deva: ['\\u0966', '\\u0967', '\\u0968', '\\u0969', '\\u096A', '\\u096B', '\\u096C', '\\u096D', '\\u096E', '\\u096F'],\r\n    fullwide: ['\\uFF10', '\\uFF11', '\\uFF12', '\\uFF13', '\\uFF14', '\\uFF15', '\\uFF16', '\\uFF17', '\\uFF18', '\\uFF19'],\r\n    gujr: ['\\u0AE6', '\\u0AE7', '\\u0AE8', '\\u0AE9', '\\u0AEA', '\\u0AEB', '\\u0AEC', '\\u0AED', '\\u0AEE', '\\u0AEF'],\r\n    guru: ['\\u0A66', '\\u0A67', '\\u0A68', '\\u0A69', '\\u0A6A', '\\u0A6B', '\\u0A6C', '\\u0A6D', '\\u0A6E', '\\u0A6F'],\r\n    hanidec: ['\\u3007', '\\u4E00', '\\u4E8C', '\\u4E09', '\\u56DB', '\\u4E94', '\\u516D', '\\u4E03', '\\u516B', '\\u4E5D'],\r\n    khmr: ['\\u17E0', '\\u17E1', '\\u17E2', '\\u17E3', '\\u17E4', '\\u17E5', '\\u17E6', '\\u17E7', '\\u17E8', '\\u17E9'],\r\n    knda: ['\\u0CE6', '\\u0CE7', '\\u0CE8', '\\u0CE9', '\\u0CEA', '\\u0CEB', '\\u0CEC', '\\u0CED', '\\u0CEE', '\\u0CEF'],\r\n    laoo: ['\\u0ED0', '\\u0ED1', '\\u0ED2', '\\u0ED3', '\\u0ED4', '\\u0ED5', '\\u0ED6', '\\u0ED7', '\\u0ED8', '\\u0ED9'],\r\n    latn: ['\\u0030', '\\u0031', '\\u0032', '\\u0033', '\\u0034', '\\u0035', '\\u0036', '\\u0037', '\\u0038', '\\u0039'],\r\n    limb: ['\\u1946', '\\u1947', '\\u1948', '\\u1949', '\\u194A', '\\u194B', '\\u194C', '\\u194D', '\\u194E', '\\u194F'],\r\n    mlym: ['\\u0D66', '\\u0D67', '\\u0D68', '\\u0D69', '\\u0D6A', '\\u0D6B', '\\u0D6C', '\\u0D6D', '\\u0D6E', '\\u0D6F'],\r\n    mong: ['\\u1810', '\\u1811', '\\u1812', '\\u1813', '\\u1814', '\\u1815', '\\u1816', '\\u1817', '\\u1818', '\\u1819'],\r\n    mymr: ['\\u1040', '\\u1041', '\\u1042', '\\u1043', '\\u1044', '\\u1045', '\\u1046', '\\u1047', '\\u1048', '\\u1049'],\r\n    orya: ['\\u0B66', '\\u0B67', '\\u0B68', '\\u0B69', '\\u0B6A', '\\u0B6B', '\\u0B6C', '\\u0B6D', '\\u0B6E', '\\u0B6F'],\r\n    tamldec: ['\\u0BE6', '\\u0BE7', '\\u0BE8', '\\u0BE9', '\\u0BEA', '\\u0BEB', '\\u0BEC', '\\u0BED', '\\u0BEE', '\\u0BEF'],\r\n    telu: ['\\u0C66', '\\u0C67', '\\u0C68', '\\u0C69', '\\u0C6A', '\\u0C6B', '\\u0C6C', '\\u0C6D', '\\u0C6E', '\\u0C6F'],\r\n    thai: ['\\u0E50', '\\u0E51', '\\u0E52', '\\u0E53', '\\u0E54', '\\u0E55', '\\u0E56', '\\u0E57', '\\u0E58', '\\u0E59'],\r\n    tibt: ['\\u0F20', '\\u0F21', '\\u0F22', '\\u0F23', '\\u0F24', '\\u0F25', '\\u0F26', '\\u0F27', '\\u0F28', '\\u0F29']\r\n};\r\n\r\n/**\r\n * This function provides access to the locale and formatting options computed\r\n * during initialization of the object.\r\n *\r\n * The function returns a new object whose properties and attributes are set as\r\n * if constructed by an object literal assigning to each of the following\r\n * properties the value of the corresponding internal property of this\r\n * NumberFormat object (see 11.4): locale, numberingSystem, style, currency,\r\n * currencyDisplay, minimumIntegerDigits, minimumFractionDigits,\r\n * maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, and\r\n * useGrouping. Properties whose corresponding internal properties are not present\r\n * are not assigned.\r\n */\r\n/* 11.3.3 */defineProperty(Intl.NumberFormat.prototype, 'resolvedOptions', {\r\n    configurable: true,\r\n    writable: true,\r\n    value: function () {\r\n        let prop,\r\n            descs = new Record(),\r\n            props = [\r\n                'locale', 'numberingSystem', 'style', 'currency', 'currencyDisplay',\r\n                'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits',\r\n                'minimumSignificantDigits', 'maximumSignificantDigits', 'useGrouping'\r\n            ],\r\n            internal = this !== null && typeof this === 'object' && getInternalProperties(this);\r\n\r\n        // Satisfy test 11.3_b\r\n        if (!internal || !internal['[[initializedNumberFormat]]'])\r\n            throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.NumberFormat object.');\r\n\r\n        for (let i = 0, max = props.length; i < max; i++) {\r\n            if (hop.call(internal, prop = '[['+ props[i] +']]'))\r\n                descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\r\n        }\r\n\r\n        return objCreate({}, descs);\r\n    }\r\n});\r\n","/* jslint esnext: true */\r\n\r\n// Match these datetime components in a CLDR pattern, except those in single quotes\r\nlet expDTComponents = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;\r\n// trim patterns after transformations\r\nlet expPatternTrimmer = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\r\n// Skip over patterns with these datetime components because we don't have data\r\n// to back them up:\r\n// timezone, weekday, amoung others\r\nlet unwantedDTCs = /[rqQASjJgwWIQq]/; // xXVO were removed from this list in favor of computing matches with timeZoneName values but printing as empty string\r\n\r\nlet dtKeys = [\"era\", \"year\", \"month\", \"day\", \"weekday\", \"quarter\"];\r\nlet tmKeys = [\"hour\", \"minute\", \"second\", \"hour12\", \"timeZoneName\"];\r\n\r\nfunction isDateFormatOnly(obj) {\r\n    for (let i = 0; i < tmKeys.length; i += 1) {\r\n        if (obj.hasOwnProperty(tmKeys[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction isTimeFormatOnly(obj) {\r\n    for (let i = 0; i < dtKeys.length; i += 1) {\r\n        if (obj.hasOwnProperty(dtKeys[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction joinDateAndTimeFormats(dateFormatObj, timeFormatObj) {\r\n    let o = { _: {} };\r\n    for (let i = 0; i < dtKeys.length; i += 1) {\r\n        if (dateFormatObj[dtKeys[i]]) {\r\n            o[dtKeys[i]] = dateFormatObj[dtKeys[i]];\r\n        }\r\n        if (dateFormatObj._[dtKeys[i]]) {\r\n            o._[dtKeys[i]] = dateFormatObj._[dtKeys[i]];\r\n        }\r\n    }\r\n    for (let j = 0; j < tmKeys.length; j += 1) {\r\n        if (timeFormatObj[tmKeys[j]]) {\r\n            o[tmKeys[j]] = timeFormatObj[tmKeys[j]];\r\n        }\r\n        if (timeFormatObj._[tmKeys[j]]) {\r\n            o._[tmKeys[j]] = timeFormatObj._[tmKeys[j]];\r\n        }\r\n    }\r\n    return o;\r\n}\r\n\r\nfunction computeFinalPatterns(formatObj) {\r\n    // From http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns:\r\n    //  'In patterns, two single quotes represents a literal single quote, either\r\n    //   inside or outside single quotes. Text within single quotes is not\r\n    //   interpreted in any way (except for two adjacent single quotes).'\r\n    formatObj.pattern12 = formatObj.extendedPattern.replace(/'([^']*)'/g, ($0, literal) => {\r\n        return literal ? literal : \"'\";\r\n    });\r\n\r\n    // pattern 12 is always the default. we can produce the 24 by removing {ampm}\r\n    formatObj.pattern = formatObj.pattern12.replace('{ampm}', '').replace(expPatternTrimmer, '');\r\n    return formatObj;\r\n}\r\n\r\nfunction expDTComponentsMeta($0, formatObj) {\r\n    switch ($0.charAt(0)) {\r\n        // --- Era\r\n        case 'G':\r\n            formatObj.era = [ 'short', 'short', 'short', 'long', 'narrow' ][$0.length-1];\r\n            return '{era}';\r\n\r\n        // --- Year\r\n        case 'y':\r\n        case 'Y':\r\n        case 'u':\r\n        case 'U':\r\n        case 'r':\r\n            formatObj.year = $0.length === 2 ? '2-digit' : 'numeric';\r\n            return '{year}';\r\n\r\n        // --- Quarter (not supported in this polyfill)\r\n        case 'Q':\r\n        case 'q':\r\n            formatObj.quarter = [ 'numeric', '2-digit', 'short', 'long', 'narrow' ][$0.length-1];\r\n            return '{quarter}';\r\n\r\n        // --- Month\r\n        case 'M':\r\n        case 'L':\r\n            formatObj.month = [ 'numeric', '2-digit', 'short', 'long', 'narrow' ][$0.length-1];\r\n            return '{month}';\r\n\r\n        // --- Week (not supported in this polyfill)\r\n        case 'w':\r\n            // week of the year\r\n            formatObj.week = $0.length === 2 ? '2-digit' : 'numeric';\r\n            return '{weekday}';\r\n        case 'W':\r\n            // week of the month\r\n            formatObj.week = 'numeric';\r\n            return '{weekday}';\r\n\r\n        // --- Day\r\n        case 'd':\r\n            // day of the month\r\n            formatObj.day = $0.length === 2 ? '2-digit' : 'numeric';\r\n            return '{day}';\r\n        case 'D': // day of the year\r\n        case 'F': // day of the week\r\n        case 'g':\r\n            // 1..n: Modified Julian day\r\n            formatObj.day = 'numeric';\r\n            return '{day}';\r\n\r\n        // --- Week Day\r\n        case 'E':\r\n            // day of the week\r\n            formatObj.weekday = [ 'short', 'short', 'short', 'long', 'narrow', 'short' ][$0.length-1];\r\n            return '{weekday}';\r\n        case 'e':\r\n            // local day of the week\r\n            formatObj.weekday = [ 'numeric', '2-digit', 'short', 'long', 'narrow', 'short' ][$0.length-1];\r\n            return '{weekday}';\r\n        case 'c':\r\n            // stand alone local day of the week\r\n            formatObj.weekday = [ 'numeric', undefined, 'short', 'long', 'narrow', 'short' ][$0.length-1];\r\n            return '{weekday}';\r\n\r\n        // --- Period\r\n        case 'a': // AM, PM\r\n        case 'b': // am, pm, noon, midnight\r\n        case 'B': // flexible day periods\r\n            formatObj.hour12 = true;\r\n            return '{ampm}';\r\n\r\n        // --- Hour\r\n        case 'h':\r\n        case 'H':\r\n            formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\r\n            return '{hour}';\r\n        case 'k':\r\n        case 'K':\r\n            formatObj.hour12 = true; // 12-hour-cycle time formats (using h or K)\r\n            formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\r\n            return '{hour}';\r\n\r\n        // --- Minute\r\n        case 'm':\r\n            formatObj.minute = $0.length === 2 ? '2-digit' : 'numeric';\r\n            return '{minute}';\r\n\r\n        // --- Second\r\n        case 's':\r\n            formatObj.second = $0.length === 2 ? '2-digit' : 'numeric';\r\n            return '{second}';\r\n        case 'S':\r\n        case 'A':\r\n            formatObj.second = 'numeric';\r\n            return '{second}';\r\n\r\n        // --- Timezone\r\n        case 'z': // 1..3, 4: specific non-location format\r\n        case 'Z': // 1..3, 4, 5: The ISO8601 varios formats\r\n        case 'O': // 1, 4: miliseconds in day short, long\r\n        case 'v': // 1, 4: generic non-location format\r\n        case 'V': // 1, 2, 3, 4: time zone ID or city\r\n        case 'X': // 1, 2, 3, 4: The ISO8601 varios formats\r\n        case 'x': // 1, 2, 3, 4: The ISO8601 varios formats\r\n            // this polyfill only supports much, for now, we are just doing something dummy\r\n            formatObj.timeZoneName = $0.length < 4 ? 'short' : 'long';\r\n            return '{timeZoneName}';\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Converts the CLDR availableFormats into the objects and patterns required by\r\n * the ECMAScript Internationalization API specification.\r\n */\r\nexport function createDateTimeFormat(skeleton, pattern) {\r\n    // we ignore certain patterns that are unsupported to avoid this expensive op.\r\n    if (unwantedDTCs.test(pattern))\r\n        return undefined;\r\n\r\n    let formatObj = {\r\n        originalPattern: pattern,\r\n        _: {}\r\n    };\r\n\r\n    // Replace the pattern string with the one required by the specification, whilst\r\n    // at the same time evaluating it for the subsets and formats\r\n    formatObj.extendedPattern = pattern.replace(expDTComponents, ($0) => {\r\n        // See which symbol we're dealing with\r\n        return expDTComponentsMeta($0, formatObj._);\r\n    });\r\n\r\n    // Match the skeleton string with the one required by the specification\r\n    // this implementation is based on the Date Field Symbol Table:\r\n    // http://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\r\n    // Note: we are adding extra data to the formatObject even though this polyfill\r\n    //       might not support it.\r\n    skeleton.replace(expDTComponents, ($0) => {\r\n        // See which symbol we're dealing with\r\n        return expDTComponentsMeta($0, formatObj);\r\n    });\r\n\r\n    return computeFinalPatterns(formatObj);\r\n}\r\n\r\n/**\r\n * Processes DateTime formats from CLDR to an easier-to-parse format.\r\n * the result of this operation should be cached the first time a particular\r\n * calendar is analyzed.\r\n *\r\n * The specification requires we support at least the following subsets of\r\n * date/time components:\r\n *\r\n *   - 'weekday', 'year', 'month', 'day', 'hour', 'minute', 'second'\r\n *   - 'weekday', 'year', 'month', 'day'\r\n *   - 'year', 'month', 'day'\r\n *   - 'year', 'month'\r\n *   - 'month', 'day'\r\n *   - 'hour', 'minute', 'second'\r\n *   - 'hour', 'minute'\r\n *\r\n * We need to cherry pick at least these subsets from the CLDR data and convert\r\n * them into the pattern objects used in the ECMA-402 API.\r\n */\r\nexport function createDateTimeFormats(formats) {\r\n    let availableFormats = formats.availableFormats;\r\n    let timeFormats = formats.timeFormats;\r\n    let dateFormats = formats.dateFormats;\r\n    let result = [];\r\n    let skeleton, pattern, computed, i, j;\r\n    let timeRelatedFormats = [];\r\n    let dateRelatedFormats = [];\r\n\r\n    // Map available (custom) formats into a pattern for createDateTimeFormats\r\n    for (skeleton in availableFormats) {\r\n        if (availableFormats.hasOwnProperty(skeleton)) {\r\n            pattern = availableFormats[skeleton];\r\n            computed = createDateTimeFormat(skeleton, pattern);\r\n            if (computed) {\r\n                result.push(computed);\r\n                // in some cases, the format is only displaying date specific props\r\n                // or time specific props, in which case we need to also produce the\r\n                // combined formats.\r\n                if (isDateFormatOnly(computed)) {\r\n                    dateRelatedFormats.push(computed);\r\n                } else if (isTimeFormatOnly(computed)) {\r\n                    timeRelatedFormats.push(computed);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Map time formats into a pattern for createDateTimeFormats\r\n    for (skeleton in timeFormats) {\r\n        if (timeFormats.hasOwnProperty(skeleton)) {\r\n            pattern = timeFormats[skeleton];\r\n            computed = createDateTimeFormat(skeleton, pattern);\r\n            if (computed) {\r\n                result.push(computed);\r\n                timeRelatedFormats.push(computed);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Map date formats into a pattern for createDateTimeFormats\r\n    for (skeleton in dateFormats) {\r\n        if (dateFormats.hasOwnProperty(skeleton)) {\r\n            pattern = dateFormats[skeleton];\r\n            computed = createDateTimeFormat(skeleton, pattern);\r\n            if (computed) {\r\n                result.push(computed);\r\n                dateRelatedFormats.push(computed);\r\n            }\r\n        }\r\n    }\r\n\r\n    // combine custom time and custom date formats when they are orthogonals to complete the\r\n    // formats supported by CLDR.\r\n    // This Algo is based on section \"Missing Skeleton Fields\" from:\r\n    // http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\r\n    for (i = 0; i < timeRelatedFormats.length; i += 1) {\r\n        for (j = 0; j < dateRelatedFormats.length; j += 1) {\r\n            if (dateRelatedFormats[j].month === 'long') {\r\n                pattern = dateRelatedFormats[j].weekday ? formats.full : formats.long;\r\n            } else if (dateRelatedFormats[j].month === 'short') {\r\n                pattern = formats.medium;\r\n            } else {\r\n                pattern = formats.short;\r\n            }\r\n            computed = joinDateAndTimeFormats(dateRelatedFormats[j], timeRelatedFormats[i]);\r\n            computed.originalPattern = pattern;\r\n            computed.extendedPattern = pattern\r\n                .replace('{0}', timeRelatedFormats[i].extendedPattern)\r\n                .replace('{1}', dateRelatedFormats[j].extendedPattern)\r\n                .replace(/^[,\\s]+|[,\\s]+$/gi, '');\r\n            result.push(computeFinalPatterns(computed));\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n// this represents the exceptions of the rule that are not covered by CLDR availableFormats\r\n// for single property configurations, they play no role when using multiple properties, and\r\n// those that are not in this table, are not exceptions or are not covered by the data we\r\n// provide.\r\nconst validSyntheticProps = {\r\n    second: {\r\n        numeric:   's',\r\n        '2-digit': 'ss'\r\n    },\r\n    minute: {\r\n        numeric:   'm',\r\n        '2-digit': 'mm'\r\n    },\r\n    year: {\r\n        numeric:   'y',\r\n        '2-digit': 'yy'\r\n    },\r\n    day: {\r\n        numeric:   'd',\r\n        '2-digit': 'dd'\r\n    },\r\n    month: {\r\n        numeric:   'L',\r\n        '2-digit': 'LL',\r\n        narrow:    'LLLLL',\r\n        short:     'LLL',\r\n        long:      'LLLL'\r\n    },\r\n    weekday: {\r\n        narrow:  'ccccc',\r\n        short:   'ccc',\r\n        long:    'cccc'\r\n    }\r\n};\r\n\r\nexport function generateSyntheticFormat(propName, propValue) {\r\n    if (validSyntheticProps[propName] && validSyntheticProps[propName][propValue]) {\r\n        return {\r\n            originalPattern: validSyntheticProps[propName][propValue],\r\n            _: {\r\n                [propName]: propValue\r\n            },\r\n            extendedPattern: `{${propName}}`,\r\n            [propName]: propValue,\r\n            pattern12: `{${propName}}`,\r\n            pattern: `{${propName}}`\r\n        };\r\n    }\r\n}\r\n","// 12.1 The Intl.DateTimeFormat constructor\r\n// ==================================\r\n\r\nimport {\r\n    toLatinUpperCase\r\n} from './6.locales-currencies-tz.js';\r\n\r\nimport {\r\n    Intl\r\n} from \"./8.intl.js\";\r\n\r\nimport {\r\n    CanonicalizeLocaleList,\r\n    ResolveLocale,\r\n    GetOption,\r\n    SupportedLocales\r\n} from \"./9.negotiation.js\";\r\n\r\nimport {\r\n    FormatNumber\r\n} from \"./11.numberformat.js\";\r\n\r\nimport {\r\n    generateSyntheticFormat,\r\n    createDateTimeFormats\r\n} from \"./cldr\";\r\n\r\nimport {\r\n    internals,\r\n    es3,\r\n    fnBind,\r\n    defineProperty,\r\n    toObject,\r\n    getInternalProperties,\r\n    createRegExpRestore,\r\n    secret,\r\n    Record,\r\n    List,\r\n    hop,\r\n    objCreate,\r\n    toNumber,\r\n    arrPush,\r\n    arrIndexOf\r\n} from './util.js';\r\n\r\n// An object map of date component keys, saves using a regex later\r\nconst dateWidths = objCreate(null, { narrow:{}, short:{}, long:{} });\r\n\r\n/**\r\n * Returns a string for a date component, resolved using multiple inheritance as specified\r\n * as specified in the Unicode Technical Standard 35.\r\n */\r\nfunction resolveDateString(data, ca, component, width, key) {\r\n    // From http://www.unicode.org/reports/tr35/tr35.html#Multiple_Inheritance:\r\n    // 'In clearly specified instances, resources may inherit from within the same locale.\r\n    //  For example, ... the Buddhist calendar inherits from the Gregorian calendar.'\r\n    let obj = data[ca] && data[ca][component]\r\n                ? data[ca][component]\r\n                : data.gregory[component],\r\n\r\n        // \"sideways\" inheritance resolves strings when a key doesn't exist\r\n        alts = {\r\n            narrow: ['short', 'long'],\r\n            short:  ['long', 'narrow'],\r\n            long:   ['short', 'narrow']\r\n        },\r\n\r\n        //\r\n        resolved = hop.call(obj, width)\r\n                  ? obj[width]\r\n                  : hop.call(obj, alts[width][0])\r\n                      ? obj[alts[width][0]]\r\n                      : obj[alts[width][1]];\r\n\r\n    // `key` wouldn't be specified for components 'dayPeriods'\r\n    return key !== null ? resolved[key] : resolved;\r\n}\r\n\r\n// Define the DateTimeFormat constructor internally so it cannot be tainted\r\nexport function DateTimeFormatConstructor () {\r\n    let locales = arguments[0];\r\n    let options = arguments[1];\r\n\r\n    if (!this || this === Intl) {\r\n        return new Intl.DateTimeFormat(locales, options);\r\n    }\r\n    return InitializeDateTimeFormat(toObject(this), locales, options);\r\n}\r\n\r\ndefineProperty(Intl, 'DateTimeFormat', {\r\n    configurable: true,\r\n    writable: true,\r\n    value: DateTimeFormatConstructor\r\n});\r\n\r\n// Must explicitly set prototypes as unwritable\r\ndefineProperty(DateTimeFormatConstructor, 'prototype', {\r\n    writable: false\r\n});\r\n\r\n/**\r\n * The abstract operation InitializeDateTimeFormat accepts the arguments dateTimeFormat\r\n * (which must be an object), locales, and options. It initializes dateTimeFormat as a\r\n * DateTimeFormat object.\r\n */\r\nexport function/* 12.1.1.1 */InitializeDateTimeFormat (dateTimeFormat, locales, options) {\r\n    // This will be a internal properties object if we're not already initialized\r\n    let internal = getInternalProperties(dateTimeFormat);\r\n\r\n    // Create an object whose props can be used to restore the values of RegExp props\r\n    let regexpRestore = createRegExpRestore();\r\n\r\n    // 1. If dateTimeFormat has an [[initializedIntlObject]] internal property with\r\n    //    value true, throw a TypeError exception.\r\n    if (internal['[[initializedIntlObject]]'] === true)\r\n        throw new TypeError('`this` object has already been initialized as an Intl object');\r\n\r\n    // Need this to access the `internal` object\r\n    defineProperty(dateTimeFormat, '__getInternalProperties', {\r\n        value: function () {\r\n            // NOTE: Non-standard, for internal use only\r\n            if (arguments[0] === secret)\r\n                return internal;\r\n        }\r\n    });\r\n\r\n    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\r\n    internal['[[initializedIntlObject]]'] = true;\r\n\r\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\r\n    //    abstract operation (defined in 9.2.1) with argument locales.\r\n    let requestedLocales = CanonicalizeLocaleList(locales);\r\n\r\n    // 4. Let options be the result of calling the ToDateTimeOptions abstract\r\n    //    operation (defined below) with arguments options, \"any\", and \"date\".\r\n    options = ToDateTimeOptions(options, 'any', 'date');\r\n\r\n    // 5. Let opt be a new Record.\r\n    let opt = new Record();\r\n\r\n    // 6. Let matcher be the result of calling the GetOption abstract operation\r\n    //    (defined in 9.2.9) with arguments options, \"localeMatcher\", \"string\", a List\r\n    //    containing the two String values \"lookup\" and \"best fit\", and \"best fit\".\r\n    let matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\r\n\r\n    // 7. Set opt.[[localeMatcher]] to matcher.\r\n    opt['[[localeMatcher]]'] = matcher;\r\n\r\n    // 8. Let DateTimeFormat be the standard built-in object that is the initial\r\n    //    value of Intl.DateTimeFormat.\r\n    let DateTimeFormat = internals.DateTimeFormat; // This is what we *really* need\r\n\r\n    // 9. Let localeData be the value of the [[localeData]] internal property of\r\n    //    DateTimeFormat.\r\n    let localeData = DateTimeFormat['[[localeData]]'];\r\n\r\n    // 10. Let r be the result of calling the ResolveLocale abstract operation\r\n    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\r\n    //      DateTimeFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\r\n    //      internal property of DateTimeFormat, and localeData.\r\n    let r = ResolveLocale(DateTimeFormat['[[availableLocales]]'], requestedLocales,\r\n                opt, DateTimeFormat['[[relevantExtensionKeys]]'], localeData);\r\n\r\n    // 11. Set the [[locale]] internal property of dateTimeFormat to the value of\r\n    //     r.[[locale]].\r\n    internal['[[locale]]'] = r['[[locale]]'];\r\n\r\n    // 12. Set the [[calendar]] internal property of dateTimeFormat to the value of\r\n    //     r.[[ca]].\r\n    internal['[[calendar]]'] = r['[[ca]]'];\r\n\r\n    // 13. Set the [[numberingSystem]] internal property of dateTimeFormat to the value of\r\n    //     r.[[nu]].\r\n    internal['[[numberingSystem]]'] = r['[[nu]]'];\r\n\r\n    // The specification doesn't tell us to do this, but it's helpful later on\r\n    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\r\n\r\n    // 14. Let dataLocale be the value of r.[[dataLocale]].\r\n    let dataLocale = r['[[dataLocale]]'];\r\n\r\n    // 15. Let tz be the result of calling the [[Get]] internal method of options with\r\n    //     argument \"timeZone\".\r\n    let tz = options.timeZone;\r\n\r\n    // 16. If tz is not undefined, then\r\n    if (tz !== undefined) {\r\n        // a. Let tz be ToString(tz).\r\n        // b. Convert tz to upper case as described in 6.1.\r\n        //    NOTE: If an implementation accepts additional time zone values, as permitted\r\n        //          under certain conditions by the Conformance clause, different casing\r\n        //          rules apply.\r\n        tz = toLatinUpperCase(tz);\r\n\r\n        // c. If tz is not \"UTC\", then throw a RangeError exception.\r\n        // ###TODO: accept more time zones###\r\n        if (tz !== 'UTC')\r\n            throw new RangeError('timeZone is not supported.');\r\n    }\r\n\r\n    // 17. Set the [[timeZone]] internal property of dateTimeFormat to tz.\r\n    internal['[[timeZone]]'] = tz;\r\n\r\n    // 18. Let opt be a new Record.\r\n    opt = new Record();\r\n\r\n    // 19. For each row of Table 3, except the header row, do:\r\n    for (let prop in dateTimeComponents) {\r\n        if (!hop.call(dateTimeComponents, prop))\r\n            continue;\r\n\r\n        // 20. Let prop be the name given in the Property column of the row.\r\n        // 21. Let value be the result of calling the GetOption abstract operation,\r\n        //     passing as argument options, the name given in the Property column of the\r\n        //     row, \"string\", a List containing the strings given in the Values column of\r\n        //     the row, and undefined.\r\n        let value = GetOption(options, prop, 'string', dateTimeComponents[prop]);\r\n\r\n        // 22. Set opt.[[<prop>]] to value.\r\n        opt['[['+prop+']]'] = value;\r\n    }\r\n\r\n    // Assigned a value below\r\n    let bestFormat;\r\n\r\n    // 23. Let dataLocaleData be the result of calling the [[Get]] internal method of\r\n    //     localeData with argument dataLocale.\r\n    let dataLocaleData = localeData[dataLocale];\r\n\r\n    // 24. Let formats be the result of calling the [[Get]] internal method of\r\n    //     dataLocaleData with argument \"formats\".\r\n    //     Note: we process the CLDR formats into the spec'd structure\r\n    let formats = ToDateTimeFormats(dataLocaleData.formats);\r\n\r\n    // 25. Let matcher be the result of calling the GetOption abstract operation with\r\n    //     arguments options, \"formatMatcher\", \"string\", a List containing the two String\r\n    //     values \"basic\" and \"best fit\", and \"best fit\".\r\n    matcher = GetOption(options, 'formatMatcher', 'string', new List('basic', 'best fit'), 'best fit');\r\n\r\n    // Optimization: caching the processed formats as a one time operation by\r\n    // replacing the initial structure from localeData\r\n    dataLocaleData.formats = formats;\r\n\r\n    // 26. If matcher is \"basic\", then\r\n    if (matcher === 'basic') {\r\n        // 27. Let bestFormat be the result of calling the BasicFormatMatcher abstract\r\n        //     operation (defined below) with opt and formats.\r\n        bestFormat = BasicFormatMatcher(opt, formats);\r\n\r\n    // 28. Else\r\n    } else {\r\n        {\r\n            // diverging\r\n            let hr12 = GetOption(options, 'hour12', 'boolean'/*, undefined, undefined*/);\r\n            opt.hour12 = hr12 === undefined ? dataLocaleData.hour12 : hr12;\r\n        }\r\n        // 29. Let bestFormat be the result of calling the BestFitFormatMatcher\r\n        //     abstract operation (defined below) with opt and formats.\r\n        bestFormat = BestFitFormatMatcher(opt, formats);\r\n    }\r\n\r\n    // 30. For each row in Table 3, except the header row, do\r\n    for (let prop in dateTimeComponents) {\r\n        if (!hop.call(dateTimeComponents, prop))\r\n            continue;\r\n\r\n        // a. Let prop be the name given in the Property column of the row.\r\n        // b. Let pDesc be the result of calling the [[GetOwnProperty]] internal method of\r\n        //    bestFormat with argument prop.\r\n        // c. If pDesc is not undefined, then\r\n        if (hop.call(bestFormat, prop)) {\r\n            // i. Let p be the result of calling the [[Get]] internal method of bestFormat\r\n            //    with argument prop.\r\n            let p = bestFormat[prop];\r\n            {\r\n                // diverging\r\n                p = bestFormat._ && hop.call(bestFormat._, prop) ? bestFormat._[prop] : p;\r\n            }\r\n\r\n            // ii. Set the [[<prop>]] internal property of dateTimeFormat to p.\r\n            internal['[['+prop+']]'] = p;\r\n        }\r\n    }\r\n\r\n    let pattern; // Assigned a value below\r\n\r\n    // 31. Let hr12 be the result of calling the GetOption abstract operation with\r\n    //     arguments options, \"hour12\", \"boolean\", undefined, and undefined.\r\n    let hr12 = GetOption(options, 'hour12', 'boolean'/*, undefined, undefined*/);\r\n\r\n    // 32. If dateTimeFormat has an internal property [[hour]], then\r\n    if (internal['[[hour]]']) {\r\n        // a. If hr12 is undefined, then let hr12 be the result of calling the [[Get]]\r\n        //    internal method of dataLocaleData with argument \"hour12\".\r\n        hr12 = hr12 === undefined ? dataLocaleData.hour12 : hr12;\r\n\r\n        // b. Set the [[hour12]] internal property of dateTimeFormat to hr12.\r\n        internal['[[hour12]]'] = hr12;\r\n\r\n        // c. If hr12 is true, then\r\n        if (hr12 === true) {\r\n            // i. Let hourNo0 be the result of calling the [[Get]] internal method of\r\n            //    dataLocaleData with argument \"hourNo0\".\r\n            let hourNo0 = dataLocaleData.hourNo0;\r\n\r\n            // ii. Set the [[hourNo0]] internal property of dateTimeFormat to hourNo0.\r\n            internal['[[hourNo0]]'] = hourNo0;\r\n\r\n            // iii. Let pattern be the result of calling the [[Get]] internal method of\r\n            //      bestFormat with argument \"pattern12\".\r\n            pattern = bestFormat.pattern12;\r\n        }\r\n\r\n        // d. Else\r\n        else\r\n            // i. Let pattern be the result of calling the [[Get]] internal method of\r\n            //    bestFormat with argument \"pattern\".\r\n            pattern = bestFormat.pattern;\r\n    }\r\n\r\n    // 33. Else\r\n    else\r\n        // a. Let pattern be the result of calling the [[Get]] internal method of\r\n        //    bestFormat with argument \"pattern\".\r\n        pattern = bestFormat.pattern;\r\n\r\n    // 34. Set the [[pattern]] internal property of dateTimeFormat to pattern.\r\n    internal['[[pattern]]'] = pattern;\r\n\r\n    // 35. Set the [[boundFormat]] internal property of dateTimeFormat to undefined.\r\n    internal['[[boundFormat]]'] = undefined;\r\n\r\n    // 36. Set the [[initializedDateTimeFormat]] internal property of dateTimeFormat to\r\n    //     true.\r\n    internal['[[initializedDateTimeFormat]]'] = true;\r\n\r\n    // In ES3, we need to pre-bind the format() function\r\n    if (es3)\r\n        dateTimeFormat.format = GetFormatDateTime.call(dateTimeFormat);\r\n\r\n    // Restore the RegExp properties\r\n    regexpRestore();\r\n\r\n    // Return the newly initialised object\r\n    return dateTimeFormat;\r\n}\r\n\r\n/**\r\n * Several DateTimeFormat algorithms use values from the following table, which provides\r\n * property names and allowable values for the components of date and time formats:\r\n */\r\nlet dateTimeComponents = {\r\n         weekday: [ \"narrow\", \"short\", \"long\" ],\r\n             era: [ \"narrow\", \"short\", \"long\" ],\r\n            year: [ \"2-digit\", \"numeric\" ],\r\n           month: [ \"2-digit\", \"numeric\", \"narrow\", \"short\", \"long\" ],\r\n             day: [ \"2-digit\", \"numeric\" ],\r\n            hour: [ \"2-digit\", \"numeric\" ],\r\n          minute: [ \"2-digit\", \"numeric\" ],\r\n          second: [ \"2-digit\", \"numeric\" ],\r\n    timeZoneName: [ \"short\", \"long\" ]\r\n};\r\n\r\n/**\r\n * When the ToDateTimeOptions abstract operation is called with arguments options,\r\n * required, and defaults, the following steps are taken:\r\n */\r\nfunction ToDateTimeFormats(formats) {\r\n    if (Object.prototype.toString.call(formats) === '[object Array]') {\r\n        return formats;\r\n    }\r\n    return createDateTimeFormats(formats);\r\n}\r\n\r\n/**\r\n * When the ToDateTimeOptions abstract operation is called with arguments options,\r\n * required, and defaults, the following steps are taken:\r\n */\r\nexport function ToDateTimeOptions (options, required, defaults) {\r\n    // 1. If options is undefined, then let options be null, else let options be\r\n    //    ToObject(options).\r\n    if (options === undefined)\r\n        options = null;\r\n\r\n    else {\r\n        // (#12) options needs to be a Record, but it also needs to inherit properties\r\n        let opt2 = toObject(options);\r\n        options = new Record();\r\n\r\n        for (let k in opt2)\r\n            options[k] = opt2[k];\r\n    }\r\n\r\n    // 2. Let create be the standard built-in function object defined in ES5, 15.2.3.5.\r\n    let create = objCreate;\r\n\r\n    // 3. Let options be the result of calling the [[Call]] internal method of create with\r\n    //    undefined as the this value and an argument list containing the single item\r\n    //    options.\r\n    options = create(options);\r\n\r\n    // 4. Let needDefaults be true.\r\n    let needDefaults = true;\r\n\r\n    // 5. If required is \"date\" or \"any\", then\r\n    if (required === 'date' || required === 'any') {\r\n        // a. For each of the property names \"weekday\", \"year\", \"month\", \"day\":\r\n            // i. If the result of calling the [[Get]] internal method of options with the\r\n            //    property name is not undefined, then let needDefaults be false.\r\n        if (options.weekday !== undefined || options.year !== undefined\r\n                || options.month !== undefined || options.day !== undefined)\r\n            needDefaults = false;\r\n    }\r\n\r\n    // 6. If required is \"time\" or \"any\", then\r\n    if (required === 'time' || required === 'any') {\r\n        // a. For each of the property names \"hour\", \"minute\", \"second\":\r\n            // i. If the result of calling the [[Get]] internal method of options with the\r\n            //    property name is not undefined, then let needDefaults be false.\r\n        if (options.hour !== undefined || options.minute !== undefined || options.second !== undefined)\r\n                needDefaults = false;\r\n    }\r\n\r\n    // 7. If needDefaults is true and defaults is either \"date\" or \"all\", then\r\n    if (needDefaults && (defaults === 'date' || defaults === 'all'))\r\n        // a. For each of the property names \"year\", \"month\", \"day\":\r\n            // i. Call the [[DefineOwnProperty]] internal method of options with the\r\n            //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\r\n            //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\r\n        options.year = options.month = options.day = 'numeric';\r\n\r\n    // 8. If needDefaults is true and defaults is either \"time\" or \"all\", then\r\n    if (needDefaults && (defaults === 'time' || defaults === 'all'))\r\n        // a. For each of the property names \"hour\", \"minute\", \"second\":\r\n            // i. Call the [[DefineOwnProperty]] internal method of options with the\r\n            //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\r\n            //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\r\n        options.hour = options.minute = options.second = 'numeric';\r\n\r\n    // 9. Return options.\r\n    return options;\r\n}\r\n\r\n/**\r\n * When the BasicFormatMatcher abstract operation is called with two arguments options and\r\n * formats, the following steps are taken:\r\n */\r\nfunction BasicFormatMatcher (options, formats) {\r\n    // 1. Let removalPenalty be 120.\r\n    let removalPenalty = 120;\r\n\r\n    // 2. Let additionPenalty be 20.\r\n    let additionPenalty = 20;\r\n\r\n    // 3. Let longLessPenalty be 8.\r\n    let longLessPenalty = 8;\r\n\r\n    // 4. Let longMorePenalty be 6.\r\n    let longMorePenalty = 6;\r\n\r\n    // 5. Let shortLessPenalty be 6.\r\n    let shortLessPenalty = 6;\r\n\r\n    // 6. Let shortMorePenalty be 3.\r\n    let shortMorePenalty = 3;\r\n\r\n    // 7. Let bestScore be -Infinity.\r\n    let bestScore = -Infinity;\r\n\r\n    // 8. Let bestFormat be undefined.\r\n    let bestFormat;\r\n\r\n    // 9. Let i be 0.\r\n    let i = 0;\r\n\r\n    // 10. Assert: formats is an Array object.\r\n\r\n    // 11. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\r\n    let len = formats.length;\r\n\r\n    // 12. Repeat while i < len:\r\n    while (i < len) {\r\n        // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\r\n        let format = formats[i];\r\n\r\n        // b. Let score be 0.\r\n        let score = 0;\r\n\r\n        // c. For each property shown in Table 3:\r\n        for (let property in dateTimeComponents) {\r\n            if (!hop.call(dateTimeComponents, property))\r\n                continue;\r\n\r\n            // i. Let optionsProp be options.[[<property>]].\r\n            let optionsProp = options['[['+ property +']]'];\r\n\r\n            // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\r\n            //     with argument property.\r\n            // iii. If formatPropDesc is not undefined, then\r\n            //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\r\n            let formatProp = hop.call(format, property) ? format[property] : undefined;\r\n\r\n            // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\r\n            //     additionPenalty.\r\n            if (optionsProp === undefined && formatProp !== undefined)\r\n                score -= additionPenalty;\r\n\r\n            // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\r\n            //    removalPenalty.\r\n            else if (optionsProp !== undefined && formatProp === undefined)\r\n                score -= removalPenalty;\r\n\r\n            // vi. Else\r\n            else {\r\n                // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\r\n                //    \"long\"].\r\n                let values = [ '2-digit', 'numeric', 'narrow', 'short', 'long' ];\r\n\r\n                // 2. Let optionsPropIndex be the index of optionsProp within values.\r\n                let optionsPropIndex = arrIndexOf.call(values, optionsProp);\r\n\r\n                // 3. Let formatPropIndex be the index of formatProp within values.\r\n                let formatPropIndex = arrIndexOf.call(values, formatProp);\r\n\r\n                // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\r\n                let delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\r\n\r\n                // 5. If delta = 2, decrease score by longMorePenalty.\r\n                if (delta === 2)\r\n                    score -= longMorePenalty;\r\n\r\n                // 6. Else if delta = 1, decrease score by shortMorePenalty.\r\n                else if (delta === 1)\r\n                    score -= shortMorePenalty;\r\n\r\n                // 7. Else if delta = -1, decrease score by shortLessPenalty.\r\n                else if (delta === -1)\r\n                    score -= shortLessPenalty;\r\n\r\n                // 8. Else if delta = -2, decrease score by longLessPenalty.\r\n                else if (delta === -2)\r\n                    score -= longLessPenalty;\r\n            }\r\n        }\r\n\r\n        // d. If score > bestScore, then\r\n        if (score > bestScore) {\r\n            // i. Let bestScore be score.\r\n            bestScore = score;\r\n\r\n            // ii. Let bestFormat be format.\r\n            bestFormat = format;\r\n        }\r\n\r\n        // e. Increase i by 1.\r\n        i++;\r\n    }\r\n\r\n    // 13. Return bestFormat.\r\n    return bestFormat;\r\n}\r\n\r\n/**\r\n * When the BestFitFormatMatcher abstract operation is called with two arguments options\r\n * and formats, it performs implementation dependent steps, which should return a set of\r\n * component representations that a typical user of the selected locale would perceive as\r\n * at least as good as the one returned by BasicFormatMatcher.\r\n *\r\n * This polyfill defines the algorithm to be the same as BasicFormatMatcher,\r\n * with the addition of bonus points awarded where the requested format is of\r\n * the same data type as the potentially matching format.\r\n *\r\n * This algo relies on the concept of closest distance matching described here:\r\n * http://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\r\n * Typically a “best match” is found using a closest distance match, such as:\r\n *\r\n * Symbols requesting a best choice for the locale are replaced.\r\n *      j → one of {H, k, h, K}; C → one of {a, b, B}\r\n * -> Covered by cldr.js matching process\r\n *\r\n * For fields with symbols representing the same type (year, month, day, etc):\r\n *     Most symbols have a small distance from each other.\r\n *         M ≅ L; E ≅ c; a ≅ b ≅ B; H ≅ k ≅ h ≅ K; ...\r\n *     -> Covered by cldr.js matching process\r\n *\r\n *     Width differences among fields, other than those marking text vs numeric, are given small distance from each other.\r\n *         MMM ≅ MMMM\r\n *         MM ≅ M\r\n *     Numeric and text fields are given a larger distance from each other.\r\n *         MMM ≈ MM\r\n *     Symbols representing substantial differences (week of year vs week of month) are given much larger a distances from each other.\r\n *         d ≋ D; ...\r\n *     Missing or extra fields cause a match to fail. (But see Missing Skeleton Fields).\r\n *\r\n *\r\n * For example,\r\n *\r\n *     { month: 'numeric', day: 'numeric' }\r\n *\r\n * should match\r\n *\r\n *     { month: '2-digit', day: '2-digit' }\r\n *\r\n * rather than\r\n *\r\n *     { month: 'short', day: 'numeric' }\r\n *\r\n * This makes sense because a user requesting a formatted date with numeric parts would\r\n * not expect to see the returned format containing narrow, short or long part names\r\n */\r\nfunction BestFitFormatMatcher (options, formats) {\r\n    /** Diverging: this block implements the hack for single property configuration, eg.:\r\n     *\r\n     *      `new Intl.DateTimeFormat('en', {day: 'numeric'})`\r\n     *\r\n     * should produce a single digit with the day of the month. This is needed because\r\n     * CLDR `availableFormats` data structure doesn't cover these cases.\r\n     */\r\n    {\r\n        const optionsPropNames = [];\r\n        for (let property in dateTimeComponents) {\r\n            if (!hop.call(dateTimeComponents, property))\r\n                continue;\r\n\r\n            if (options['[['+ property +']]'] !== undefined) {\r\n                optionsPropNames.push(property);\r\n            }\r\n        }\r\n        if (optionsPropNames.length === 1) {\r\n            const bestFormat = generateSyntheticFormat(optionsPropNames[0], options['[['+ optionsPropNames[0] +']]']);\r\n            if (bestFormat) {\r\n                return bestFormat;\r\n            }\r\n        }\r\n    }\r\n\r\n    // 1. Let removalPenalty be 120.\r\n    let removalPenalty = 120;\r\n\r\n    // 2. Let additionPenalty be 20.\r\n    let additionPenalty = 20;\r\n\r\n    // 3. Let longLessPenalty be 8.\r\n    let longLessPenalty = 8;\r\n\r\n    // 4. Let longMorePenalty be 6.\r\n    let longMorePenalty = 6;\r\n\r\n    // 5. Let shortLessPenalty be 6.\r\n    let shortLessPenalty = 6;\r\n\r\n    // 6. Let shortMorePenalty be 3.\r\n    let shortMorePenalty = 3;\r\n\r\n    let patternPenalty = 2;\r\n\r\n    let hour12Penalty = 1;\r\n\r\n    // 7. Let bestScore be -Infinity.\r\n    let bestScore = -Infinity;\r\n\r\n    // 8. Let bestFormat be undefined.\r\n    let bestFormat;\r\n\r\n    // 9. Let i be 0.\r\n    let i = 0;\r\n\r\n    // 10. Assert: formats is an Array object.\r\n\r\n    // 11. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\r\n    let len = formats.length;\r\n\r\n    // 12. Repeat while i < len:\r\n    while (i < len) {\r\n        // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\r\n        let format = formats[i];\r\n\r\n        // b. Let score be 0.\r\n        let score = 0;\r\n\r\n        // c. For each property shown in Table 3:\r\n        for (let property in dateTimeComponents) {\r\n            if (!hop.call(dateTimeComponents, property))\r\n                continue;\r\n\r\n            // i. Let optionsProp be options.[[<property>]].\r\n            let optionsProp = options['[['+ property +']]'];\r\n\r\n            // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\r\n            //     with argument property.\r\n            // iii. If formatPropDesc is not undefined, then\r\n            //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\r\n            let formatProp = hop.call(format, property) ? format[property] : undefined;\r\n\r\n            // Diverging: using the default properties produced by the pattern/skeleton\r\n            // to match it with user options, and apply a penalty\r\n            let patternProp = hop.call(format._, property) ? format._[property] : undefined;\r\n            if (optionsProp !== patternProp) {\r\n                score -= patternPenalty;\r\n            }\r\n\r\n            // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\r\n            //     additionPenalty.\r\n            if (optionsProp === undefined && formatProp !== undefined)\r\n                score -= additionPenalty;\r\n\r\n            // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\r\n            //    removalPenalty.\r\n            else if (optionsProp !== undefined && formatProp === undefined)\r\n                score -= removalPenalty;\r\n\r\n            // vi. Else\r\n            else {\r\n                // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\r\n                //    \"long\"].\r\n                let values = [ '2-digit', 'numeric', 'narrow', 'short', 'long' ];\r\n\r\n                // 2. Let optionsPropIndex be the index of optionsProp within values.\r\n                let optionsPropIndex = arrIndexOf.call(values, optionsProp);\r\n\r\n                // 3. Let formatPropIndex be the index of formatProp within values.\r\n                let formatPropIndex = arrIndexOf.call(values, formatProp);\r\n\r\n                // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\r\n                let delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\r\n\r\n                {\r\n                    // diverging from spec\r\n                    // When the bestFit argument is true, subtract additional penalty where data types are not the same\r\n                    if ((formatPropIndex <= 1 && optionsPropIndex >= 2) || (formatPropIndex >= 2 && optionsPropIndex <= 1)) {\r\n                        // 5. If delta = 2, decrease score by longMorePenalty.\r\n                        if (delta > 0)\r\n                            score -= longMorePenalty;\r\n                        else if (delta < 0)\r\n                            score -= longLessPenalty;\r\n                    } else {\r\n                        // 5. If delta = 2, decrease score by longMorePenalty.\r\n                        if (delta > 1)\r\n                            score -= shortMorePenalty;\r\n                        else if (delta < -1)\r\n                            score -= shortLessPenalty;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        {\r\n            // diverging to also take into consideration differences between 12 or 24 hours\r\n            // which is special for the best fit only.\r\n            if (format._.hour12 !== options.hour12) {\r\n                score -= hour12Penalty;\r\n            }\r\n        }\r\n\r\n        // d. If score > bestScore, then\r\n        if (score > bestScore) {\r\n            // i. Let bestScore be score.\r\n            bestScore = score;\r\n            // ii. Let bestFormat be format.\r\n            bestFormat = format;\r\n        }\r\n\r\n        // e. Increase i by 1.\r\n        i++;\r\n    }\r\n\r\n    // 13. Return bestFormat.\r\n    return bestFormat;\r\n}\r\n\r\n/* 12.2.3 */internals.DateTimeFormat = {\r\n    '[[availableLocales]]': [],\r\n    '[[relevantExtensionKeys]]': ['ca', 'nu'],\r\n    '[[localeData]]': {}\r\n};\r\n\r\n/**\r\n * When the supportedLocalesOf method of Intl.DateTimeFormat is called, the\r\n * following steps are taken:\r\n */\r\n/* 12.2.2 */\r\ndefineProperty(Intl.DateTimeFormat, 'supportedLocalesOf', {\r\n    configurable: true,\r\n    writable: true,\r\n    value: fnBind.call(function (locales) {\r\n        // Bound functions only have the `this` value altered if being used as a constructor,\r\n        // this lets us imitate a native function that has no constructor\r\n        if (!hop.call(this, '[[availableLocales]]'))\r\n            throw new TypeError('supportedLocalesOf() is not a constructor');\r\n\r\n        // Create an object whose props can be used to restore the values of RegExp props\r\n        let regexpRestore = createRegExpRestore(),\r\n\r\n        // 1. If options is not provided, then let options be undefined.\r\n            options = arguments[1],\r\n\r\n        // 2. Let availableLocales be the value of the [[availableLocales]] internal\r\n        //    property of the standard built-in object that is the initial value of\r\n        //    Intl.NumberFormat.\r\n\r\n            availableLocales = this['[[availableLocales]]'],\r\n\r\n        // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\r\n        //    abstract operation (defined in 9.2.1) with argument locales.\r\n            requestedLocales = CanonicalizeLocaleList(locales);\r\n\r\n        // Restore the RegExp properties\r\n        regexpRestore();\r\n\r\n        // 4. Return the result of calling the SupportedLocales abstract operation\r\n        //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\r\n        //    and options.\r\n        return SupportedLocales(availableLocales, requestedLocales, options);\r\n    }, internals.NumberFormat)\r\n});\r\n\r\n/**\r\n * This named accessor property returns a function that formats a number\r\n * according to the effective locale and the formatting options of this\r\n * DateTimeFormat object.\r\n */\r\n/* 12.3.2 */defineProperty(Intl.DateTimeFormat.prototype, 'format', {\r\n    configurable: true,\r\n    get: GetFormatDateTime\r\n});\r\n\r\nfunction GetFormatDateTime() {\r\n    let internal = this !== null && typeof this === 'object' && getInternalProperties(this);\r\n\r\n    // Satisfy test 12.3_b\r\n    if (!internal || !internal['[[initializedDateTimeFormat]]'])\r\n        throw new TypeError('`this` value for format() is not an initialized Intl.DateTimeFormat object.');\r\n\r\n    // The value of the [[Get]] attribute is a function that takes the following\r\n    // steps:\r\n\r\n    // 1. If the [[boundFormat]] internal property of this DateTimeFormat object\r\n    //    is undefined, then:\r\n    if (internal['[[boundFormat]]'] === undefined) {\r\n        // a. Let F be a Function object, with internal properties set as\r\n        //    specified for built-in functions in ES5, 15, or successor, and the\r\n        //    length property set to 0, that takes the argument date and\r\n        //    performs the following steps:\r\n        let F = function (date = undefined) {\r\n                //   i. If date is not provided or is undefined, then let x be the\r\n                //      result as if by the expression Date.now() where Date.now is\r\n                //      the standard built-in function defined in ES5, 15.9.4.4.\r\n                //  ii. Else let x be ToNumber(date).\r\n                // iii. Return the result of calling the FormatDateTime abstract\r\n                //      operation (defined below) with arguments this and x.\r\n                let x = date === undefined ? Date.now() : toNumber(date);\r\n                return FormatDateTime(this, x);\r\n            };\r\n        // b. Let bind be the standard built-in function object defined in ES5,\r\n        //    15.3.4.5.\r\n        // c. Let bf be the result of calling the [[Call]] internal method of\r\n        //    bind with F as the this value and an argument list containing\r\n        //    the single item this.\r\n        let bf = fnBind.call(F, this);\r\n        // d. Set the [[boundFormat]] internal property of this NumberFormat\r\n        //    object to bf.\r\n        internal['[[boundFormat]]'] = bf;\r\n    }\r\n    // Return the value of the [[boundFormat]] internal property of this\r\n    // NumberFormat object.\r\n    return internal['[[boundFormat]]'];\r\n}\r\n\r\nfunction formatToParts(date = undefined) {\r\n    let internal = this !== null && typeof this === 'object' && getInternalProperties(this);\r\n\r\n    if (!internal || !internal['[[initializedDateTimeFormat]]'])\r\n        throw new TypeError('`this` value for formatToParts() is not an initialized Intl.DateTimeFormat object.');\r\n\r\n    let x = date === undefined ? Date.now() : toNumber(date);\r\n    return FormatToPartsDateTime(this, x);\r\n}\r\n\r\nObject.defineProperty(Intl.DateTimeFormat.prototype, 'formatToParts', {\r\n  enumerable: false,\r\n  writable: true,\r\n  configurable: true,\r\n  value: formatToParts\r\n});\r\n\r\nfunction CreateDateTimeParts(dateTimeFormat, x) {\r\n    // 1. If x is not a finite Number, then throw a RangeError exception.\r\n    if (!isFinite(x))\r\n        throw new RangeError('Invalid valid date passed to format');\r\n\r\n    let internal = dateTimeFormat.__getInternalProperties(secret);\r\n\r\n    // Creating restore point for properties on the RegExp object... please wait\r\n    /* let regexpRestore = */createRegExpRestore(); // ###TODO: review this\r\n\r\n    // 2. Let locale be the value of the [[locale]] internal property of dateTimeFormat.\r\n    let locale = internal['[[locale]]'];\r\n\r\n    // 3. Let nf be the result of creating a new NumberFormat object as if by the\r\n    // expression new Intl.NumberFormat([locale], {useGrouping: false}) where\r\n    // Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\r\n    let nf = new Intl.NumberFormat([locale], {useGrouping: false});\r\n\r\n    // 4. Let nf2 be the result of creating a new NumberFormat object as if by the\r\n    // expression new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping:\r\n    // false}) where Intl.NumberFormat is the standard built-in constructor defined in\r\n    // 11.1.3.\r\n    let nf2 = new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping: false});\r\n\r\n    // 5. Let tm be the result of calling the ToLocalTime abstract operation (defined\r\n    // below) with x, the value of the [[calendar]] internal property of dateTimeFormat,\r\n    // and the value of the [[timeZone]] internal property of dateTimeFormat.\r\n    let tm = ToLocalTime(x, internal['[[calendar]]'], internal['[[timeZone]]']);\r\n\r\n    // 6. Let result be the value of the [[pattern]] internal property of dateTimeFormat.\r\n    let pattern = internal['[[pattern]]'];\r\n\r\n    // 7.\r\n    let result = new List();\r\n\r\n    // 8.\r\n    let index = 0;\r\n\r\n    // 9.\r\n    let beginIndex = pattern.indexOf('{');\r\n\r\n    // 10.\r\n    let endIndex = 0;\r\n\r\n    // Need the locale minus any extensions\r\n    let dataLocale = internal['[[dataLocale]]'];\r\n\r\n    // Need the calendar data from CLDR\r\n    let localeData = internals.DateTimeFormat['[[localeData]]'][dataLocale].calendars;\r\n    let ca = internal['[[calendar]]'];\r\n\r\n    // 11.\r\n        while (beginIndex !== -1) {\r\n            let fv;\r\n            // a.\r\n            endIndex = pattern.indexOf('}', beginIndex);\r\n            // b.\r\n            if (endIndex === -1) {\r\n              throw new Error('Unclosed pattern');\r\n            }\r\n            // c.\r\n            if (beginIndex > index) {\r\n                arrPush.call(result, {\r\n                    type: 'literal',\r\n                    value: pattern.substring(index, beginIndex)\r\n                });\r\n            }\r\n            // d.\r\n            let p = pattern.substring(beginIndex + 1, endIndex);\r\n            // e.\r\n            if (dateTimeComponents.hasOwnProperty(p)) {\r\n              //   i. Let f be the value of the [[<p>]] internal property of dateTimeFormat.\r\n              let f = internal['[['+ p +']]'];\r\n              //  ii. Let v be the value of tm.[[<p>]].\r\n              let v = tm['[['+ p +']]'];\r\n              // iii. If p is \"year\" and v ≤ 0, then let v be 1 - v.\r\n              if (p === 'year' && v <= 0) {\r\n                v = 1 - v;\r\n              }\r\n              //  iv. If p is \"month\", then increase v by 1.\r\n              else if (p === 'month') {\r\n                v++;\r\n              }\r\n              //   v. If p is \"hour\" and the value of the [[hour12]] internal property of\r\n              //      dateTimeFormat is true, then\r\n              else if (p === 'hour' && internal['[[hour12]]'] === true) {\r\n                  // 1. Let v be v modulo 12.\r\n                  v = v % 12;\r\n                  // 2. If v is 0 and the value of the [[hourNo0]] internal property of\r\n                  //    dateTimeFormat is true, then let v be 12.\r\n                  if (v === 0 && internal['[[hourNo0]]'] === true) {\r\n                      v = 12;\r\n                  }\r\n              }\r\n\r\n              //  vi. If f is \"numeric\", then\r\n              if (f === 'numeric') {\r\n                  // 1. Let fv be the result of calling the FormatNumber abstract operation\r\n                  //    (defined in 11.3.2) with arguments nf and v.\r\n                  fv = FormatNumber(nf, v);\r\n              }\r\n              // vii. Else if f is \"2-digit\", then\r\n              else if (f === '2-digit') {\r\n                  // 1. Let fv be the result of calling the FormatNumber abstract operation\r\n                  //    with arguments nf2 and v.\r\n                  fv = FormatNumber(nf2, v);\r\n                  // 2. If the length of fv is greater than 2, let fv be the substring of fv\r\n                  //    containing the last two characters.\r\n                  if (fv.length > 2) {\r\n                      fv = fv.slice(-2);\r\n                  }\r\n              }\r\n              // viii. Else if f is \"narrow\", \"short\", or \"long\", then let fv be a String\r\n              //     value representing f in the desired form; the String value depends upon\r\n              //     the implementation and the effective locale and calendar of\r\n              //     dateTimeFormat. If p is \"month\", then the String value may also depend\r\n              //     on whether dateTimeFormat has a [[day]] internal property. If p is\r\n              //     \"timeZoneName\", then the String value may also depend on the value of\r\n              //     the [[inDST]] field of tm.\r\n              else if (f in dateWidths) {\r\n                switch (p) {\r\n                  case 'month':\r\n                    fv = resolveDateString(localeData, ca, 'months', f, tm['[['+ p +']]']);\r\n                    break;\r\n\r\n                  case 'weekday':\r\n                    try {\r\n                      fv = resolveDateString(localeData, ca, 'days', f, tm['[['+ p +']]']);\r\n                      // fv = resolveDateString(ca.days, f)[tm['[['+ p +']]']];\r\n                    } catch (e) {\r\n                      throw new Error('Could not find weekday data for locale '+locale);\r\n                    }\r\n                    break;\r\n\r\n                  case 'timeZoneName':\r\n                    fv = ''; // ###TODO\r\n                    break;\r\n\r\n                  case 'era':\r\n                    try {\r\n                      fv = resolveDateString(localeData, ca, 'eras', f, tm['[['+ p +']]']);\r\n                    } catch (e) {\r\n                      throw new Error('Could not find era data for locale '+locale);\r\n                    }\r\n                    break;\r\n\r\n                  default:\r\n                    fv = tm['[['+ p +']]'];\r\n                }\r\n              }\r\n              // ix\r\n              arrPush.call(result, {\r\n                type: p,\r\n                value: fv\r\n              });\r\n            // f.\r\n            } else if (p === 'ampm') {\r\n              // i.\r\n              let v = tm['[[hour]]'];\r\n              // ii./iii.\r\n              fv = resolveDateString(localeData, ca, 'dayPeriods', v > 11 ? 'pm' : 'am', null);\r\n              // iv.\r\n              arrPush.call(result, {\r\n                type: 'dayPeriod',\r\n                value: fv\r\n              });\r\n            // g.\r\n            } else {\r\n              arrPush.call(result, {\r\n                type: 'literal',\r\n                value: pattern.substring(beginIndex, endIndex + 1)\r\n              });\r\n            }\r\n            // h.\r\n            index = endIndex + 1;\r\n            // i.\r\n            beginIndex = pattern.indexOf('{', index);\r\n        }\r\n        // 12.\r\n        if (endIndex < pattern.length - 1) {\r\n          arrPush.call(result, {\r\n            type: 'literal',\r\n            value: pattern.substr(endIndex + 1)\r\n          });\r\n        }\r\n        // 13.\r\n        return result;\r\n}\r\n\r\n/**\r\n * When the FormatDateTime abstract operation is called with arguments dateTimeFormat\r\n * (which must be an object initialized as a DateTimeFormat) and x (which must be a Number\r\n * value), it returns a String value representing x (interpreted as a time value as\r\n * specified in ES5, 15.9.1.1) according to the effective locale and the formatting\r\n * options of dateTimeFormat.\r\n */\r\nexport function FormatDateTime(dateTimeFormat, x) {\r\n  let parts = CreateDateTimeParts(dateTimeFormat, x);\r\n  let result = '';\r\n\r\n  for (let i = 0; parts.length > i; i++) {\r\n      let part = parts[i];\r\n      result += part.value;\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction FormatToPartsDateTime(dateTimeFormat, x) {\r\n  let parts = CreateDateTimeParts(dateTimeFormat, x);\r\n  let result = [];\r\n  for (let i = 0; parts.length > i; i++) {\r\n    let part = parts[i];\r\n    result.push({\r\n      type: part.type,\r\n      value: part.value\r\n    });\r\n  }\r\n  return result;\r\n}\r\n\r\n\r\n/**\r\n * When the ToLocalTime abstract operation is called with arguments date, calendar, and\r\n * timeZone, the following steps are taken:\r\n */\r\nfunction ToLocalTime(date, calendar, timeZone) {\r\n    // 1. Apply calendrical calculations on date for the given calendar and time zone to\r\n    //    produce weekday, era, year, month, day, hour, minute, second, and inDST values.\r\n    //    The calculations should use best available information about the specified\r\n    //    calendar and time zone. If the calendar is \"gregory\", then the calculations must\r\n    //    match the algorithms specified in ES5, 15.9.1, except that calculations are not\r\n    //    bound by the restrictions on the use of best available information on time zones\r\n    //    for local time zone adjustment and daylight saving time adjustment imposed by\r\n    //    ES5, 15.9.1.7 and 15.9.1.8.\r\n    // ###TODO###\r\n    let d = new Date(date),\r\n        m = 'get' + (timeZone || '');\r\n\r\n    // 2. Return a Record with fields [[weekday]], [[era]], [[year]], [[month]], [[day]],\r\n    //    [[hour]], [[minute]], [[second]], and [[inDST]], each with the corresponding\r\n    //    calculated value.\r\n    return new Record({\r\n        '[[weekday]]': d[m + 'Day'](),\r\n        '[[era]]'    : +(d[m + 'FullYear']() >= 0),\r\n        '[[year]]'   : d[m + 'FullYear'](),\r\n        '[[month]]'  : d[m + 'Month'](),\r\n        '[[day]]'    : d[m + 'Date'](),\r\n        '[[hour]]'   : d[m + 'Hours'](),\r\n        '[[minute]]' : d[m + 'Minutes'](),\r\n        '[[second]]' : d[m + 'Seconds'](),\r\n        '[[inDST]]'  : false // ###TODO###\r\n    });\r\n}\r\n\r\n\r\n\r\nconst dateTimeParts = {\r\n    weekday:  {\"narrow\":\"EEEEE\", \"short\":\"EEE\", \"long\":\"EEEE\" },\r\n        era: { \"narrow\":\"GGGGG\", \"short\":\"GG\", \"long\":\"GGGG\"},\r\n       year: { \"2-digit\":\"yy\", \"numeric\":\"yyyy\" },\r\n      month: { \"2-digit\":\"MM\", \"numeric\":\"M\", \"narrow\":\"MMMMM\", \"short\":\"MMM\", \"long\":\"MMMM\" },\r\n        day: { \"2-digit\":\"dd\", \"numeric\":\"d\" },\r\n       hour: { \"2-digit\":\"HH\", \"numeric\" :\"H\"},\r\n     minute: { \"2-digit\":\"mm\", \"numeric\":\"m\" },\r\n     second: { \"2-digit\":\"ss\", \"numeric\":\"s\" },\r\n  timeZoneName: { \"short\":\"zzz\", \"long\":\"zzzz\" }\r\n  };\r\n\r\nconst getFormatFromOptions=(options)=>{\r\n    let format = options.pattern;\r\n    Object.keys(dateTimeParts).forEach((key) => {\r\n        format = format.replace(`{${key}}`,(dateTimeParts[key][options[key]]));\r\n    });\r\n    return format;\r\n};\r\n\r\n/**\r\n * The function returns a new object whose properties and attributes are set as if\r\n * constructed by an object literal assigning to each of the following properties the\r\n * value of the corresponding internal property of this DateTimeFormat object (see 12.4):\r\n * locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day,\r\n * hour, minute, second, and timeZoneName. Properties whose corresponding internal\r\n * properties are not present are not assigned.\r\n */\r\n/* 12.3.3 */defineProperty(Intl.DateTimeFormat.prototype, 'resolvedOptions', {\r\n    writable: true,\r\n    configurable: true,\r\n    value: function () {\r\n\r\n        let prop,\r\n            descs = new Record(),\r\n            props = [\r\n                'locale', 'calendar', 'numberingSystem', 'timeZone', 'hour12', 'weekday',\r\n                'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName','pattern'\r\n            ],\r\n            internal = this !== null && typeof this === 'object' && getInternalProperties(this);\r\n\r\n        // Satisfy test 12.3_b\r\n        if (!internal || !internal['[[initializedDateTimeFormat]]'])\r\n            throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.DateTimeFormat object.');\r\n\r\n        for (let i = 0, max = props.length; i < max; i++) {\r\n            if (hop.call(internal, prop = '[[' + props[i] + ']]'))\r\n                descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\r\n        }\r\n        descs['resolvedFormat']={ value:getFormatFromOptions(objCreate({}, descs)), writable: true, configurable: true, enumerable: true };\r\n\r\n        return objCreate({}, descs);\r\n    }\r\n});\r\n","import plurals from '../node_modules/make-plural/es6/plurals';\r\n\r\nimport {\r\n    Intl\r\n} from './8.intl.js';\r\n\r\nimport {\r\n    GetOption,\r\n    SupportedLocales,\r\n    ResolveLocale,\r\n    CanonicalizeLocaleList\r\n} from './9.negotiation.js';\r\n\r\nimport {\r\n    SetNumberFormatDigitOptions\r\n} from './11.numberformat.js';\r\n\r\nimport {\r\n    internals,\r\n    getInternalProperties,\r\n    Record,\r\n    List,\r\n    hop,\r\n    objCreate,\r\n    fnBind,\r\n    toObject,\r\n    secret,\r\n    createRegExpRestore,\r\n    defineProperty\r\n} from './util.js';\r\n\r\nexport function PluralRules() {\r\n    let locales = arguments[0];\r\n    let options = arguments[1];\r\n\r\n    if (!this || this === Intl) {\r\n        return new Intl.PluralRules(locales, options);\r\n    }\r\n    return InitializePluralRules(toObject(this), locales, options);\r\n}\r\n\r\ndefineProperty(Intl, 'PluralRules', {\r\n    configurable: true,\r\n    writable: true,\r\n    value: PluralRules\r\n});\r\n\r\ndefineProperty(PluralRules, 'prototype', {\r\n    writable: false\r\n});\r\n\r\nexport function InitializePluralRules (pluralRules, locales, options) {\r\n    let internal = getInternalProperties(pluralRules);\r\n\r\n    // 1. If pluralRules.[[InitializedIntlObject]] is true, throw a TypeError exception.\r\n    if (internal['[[InitializedIntlObject]]'] === true)\r\n        throw new TypeError('`this` object has already been initialized as an Intl object');\r\n\r\n    defineProperty(pluralRules, '__getInternalProperties', {\r\n        value: function () {\r\n            // NOTE: Non-standard, for internal use only\r\n            if (arguments[0] === secret)\r\n                return internal;\r\n        }\r\n    });\r\n\r\n    // 2. Set pluralRules.[[InitializedIntlObject]] to true.\r\n    internal['[[InitializedIntlObject]]'] = true;\r\n\r\n    // 3. Let requestedLocales be ? CanonicalizeLocaleList(locales).\r\n    let requestedLocales = CanonicalizeLocaleList(locales);\r\n\r\n    // 4. If options is undefined, then\r\n    if (options === undefined)\r\n        // a. Let options be ObjectCreate(%ObjectPrototype%).\r\n        options = {};\r\n    // 5. Else\r\n    else\r\n        // a. Let options be ? ToObject(options).\r\n        options = toObject(options);\r\n\r\n    // 6. Let t be ? GetOption(options, \"type\", \"string\", « \"cardinal\", \"ordinal\" », \"cardinal\").\r\n    let t = GetOption(options, 'type', 'string', new List('cardinal', 'ordinal'), 'cardinal');\r\n\r\n    // 7 . Set pluralRules.[[Type]] to t.\r\n    internal['[[type]]'] = t;\r\n\r\n    // 8. Let opt be a new Record.\r\n    let opt = new Record();\r\n\r\n    // 9. Let matcher be ? GetOption(options, \"localeMatcher\", \"string\", « \"lookup\", \"best fit\" », \"best fit\").\r\n    let matcher =  GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\r\n    // 10. Set opt.[[localeMatcher]] to matcher.\r\n    opt['[[localeMatcher]]'] = matcher;\r\n\r\n    // 11. Perform ? SetNumberFormatOptions(pluralRules, options, 0).\r\n    SetNumberFormatDigitOptions(internals, options, 0);\r\n\r\n    // 12. If pluralRules.[[maximumFractionDigits]] is undefined, then\r\n    if (internals['[[maximumFractionDigits]]'] === undefined) {\r\n        // a. Set pluralRules.[[maximumFractionDigits]] to max(pluralRules.[[minimumFractionDigits]], 3).\r\n        internals['[[maximumFractionDigits]]'] = Math.max(internals['[[minimumFractionDigits]]'], 3);\r\n    }\r\n\r\n    let localeData = internals.PluralRules['[[localeData]]'];\r\n\r\n    // 13. Let r be ResolveLocale(%PluralRules%.[[AvailableLocales]], requestedLocales, opt).\r\n    let r = ResolveLocale(\r\n        internals.PluralRules['[[availableLocales]]'], requestedLocales,\r\n        opt, internals.PluralRules['[[relevantExtensionKeys]]'], localeData\r\n    );\r\n\r\n    // 14. Set pluralRules.[[Locale]] to the value of r.[[Locale]].\r\n    internal['[[locale]]'] = r['[[locale]]'];\r\n\r\n    // 15. Set pluralRules.[[InitializedPluralRules]] to true.\r\n    internal['[[InitializedPluralRules]]'] = true;\r\n\r\n    // 16. Return pluralRules.\r\n    return pluralRules;\r\n}\r\n\r\n// make-plurals handls GetOperands\r\nfunction PluralRuleSelection(locale, type, s) {\r\n    for (let l = locale; l; l = l.replace(/[-_]?[^-_]*$/, '')) {\r\n        const pf = plurals[l];\r\n        if (pf) return pf(s, type === 'ordinal');\r\n    }\r\n    return 'other';\r\n}\r\n\r\nfunction ResolvePlural(pluralRules, n) {\r\n    // 1. Assert: Type(pluralRules) is Object and pluralRules has an [[InitializedPluralRules]] internal slot whose value is true.\r\n\r\n    // 2. Assert: Type(n) is Number.\r\n\r\n    // 3. If isFinite(n) is false, then\r\n    if (!Number.isFinite(n)) {\r\n        // a. Return \"other\".\r\n        return 'other';\r\n    }\r\n\r\n    let internal = getInternalProperties(pluralRules);\r\n\r\n    // 4. Let locale be pluralRules.[[Locale]].\r\n    let locale = internal['[[locale]]'];\r\n\r\n    // 5. Let type be pluralRules.[[Type]].\r\n    let type = internal['[[type]]'];\r\n\r\n    // 8. Return ? PluralRuleSelection(locale, type, n, operands). \r\n    return PluralRuleSelection(locale, type, n);\r\n}\r\n\r\ninternals.PluralRules = {\r\n    '[[availableLocales]]' : Object.keys(plurals),\r\n    '[[relevantExtensionKeys]]': [],\r\n    '[[localeData]]': {}\r\n};\r\n\r\ndefineProperty(Intl.PluralRules, 'supportedLocalesOf', {\r\n    configurable: true,\r\n    writable: true,\r\n    value: fnBind.call(function (locales) {\r\n        // Bound functions only have the `this` value altered if being used as a constructor,\r\n        // this lets us imitate a native function that has no constructor\r\n        if (!hop.call(this, '[[availableLocales]]'))\r\n            throw new TypeError('supportedLocalesOf() is not a constructor');\r\n\r\n        // Create an object whose props can be used to restore the values of RegExp props\r\n        let regexpRestore = createRegExpRestore(),\r\n\r\n            // 1. If options is not provided, then let options be undefined.\r\n            options = arguments[1],\r\n\r\n            // 2. Let availableLocales be the value of the [[availableLocales]] internal\r\n            //    property of the standard built-in object that is the initial value of\r\n            //    Intl.NumberFormat.\r\n\r\n            availableLocales = this['[[availableLocales]]'],\r\n\r\n            // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\r\n            //    abstract operation (defined in 9.2.1) with argument locales.\r\n            requestedLocales = CanonicalizeLocaleList(locales);\r\n\r\n        // Restore the RegExp properties\r\n        regexpRestore();\r\n\r\n        // 4. Return the result of calling the SupportedLocales abstract operation\r\n        //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\r\n        //    and options.\r\n        return SupportedLocales(availableLocales, requestedLocales, options);\r\n    }, internals.PluralRules)\r\n});\r\n\r\n\r\n\r\ndefineProperty(Intl.PluralRules.prototype, 'select', {\r\n    configurable: true,\r\n    value: function(value) {\r\n        let pluralRules = this;\r\n        let n = Number(value);\r\n        return ResolvePlural(pluralRules, n);\r\n    }\r\n});\r\n\r\ndefineProperty(Intl.PluralRules.prototype, 'resolvedOptions', {\r\n    configurable: true,\r\n    writable: true,\r\n    value: function() {\r\n        let prop,\r\n            descs = new Record(),\r\n            props = [\r\n                'locale', 'type',\r\n                'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits',\r\n                'minimumSignificantDigits', 'maximumSignificantDigits'\r\n            ],\r\n            internal = this !== null && typeof this === 'object' && getInternalProperties(this);\r\n\r\n        if (!internal || !internal['[[InitializedPluralRules]]'])\r\n            throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.PluralRules object.');\r\n\r\n        for (let i = 0, max = props.length; i < max; i++) {\r\n            if (hop.call(internal, prop = '[['+ props[i] +']]'))\r\n                descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\r\n        }\r\n\r\n        return objCreate({}, descs);\r\n    }\r\n});\r\n","/**\r\n * @license Copyright 2013 Andy Earnshaw, MIT License\r\n *\r\n * Implements the ECMAScript Internationalization API in ES5-compatible environments,\r\n * following the ECMA-402 specification as closely as possible\r\n *\r\n * ECMA-402: http://ecma-international.org/ecma-402/1.0/\r\n *\r\n * CLDR format locale data should be provided using IntlPolyfill.__addLocaleData().\r\n */\r\n\r\nimport {\r\n    defineProperty,\r\n    hop,\r\n    arrPush,\r\n    arrShift,\r\n    internals\r\n} from \"./util.js\";\r\n\r\nimport {\r\n    IsStructurallyValidLanguageTag,\r\n    defaultLocale,\r\n    setDefaultLocale\r\n} from \"./6.locales-currencies-tz.js\";\r\n\r\nimport {\r\n    Intl\r\n} from \"./8.intl.js\";\r\n\r\nimport \"./11.numberformat.js\";\r\n\r\nimport \"./12.datetimeformat.js\";\r\n\r\nimport ls from \"./13.locale-sensitive-functions.js\";\r\n\r\nimport \"./14.pluralrules.js\";\r\n\r\ndefineProperty(Intl, '__applyLocaleSensitivePrototypes', {\r\n    writable: true,\r\n    configurable: true,\r\n    value: function () {\r\n        defineProperty(Number.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Number.toLocaleString });\r\n        // Need this here for IE 8, to avoid the _DontEnum_ bug\r\n        defineProperty(Date.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Date.toLocaleString });\r\n\r\n        for (let k in ls.Date) {\r\n            if (hop.call(ls.Date, k))\r\n                defineProperty(Date.prototype, k, { writable: true, configurable: true, value: ls.Date[k] });\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Can't really ship a single script with data for hundreds of locales, so we provide\r\n * this __addLocaleData method as a means for the developer to add the data on an\r\n * as-needed basis\r\n */\r\ndefineProperty(Intl, '__addLocaleData', {\r\n    value: function (data) {\r\n        if (!IsStructurallyValidLanguageTag(data.locale))\r\n            throw new Error(`Invalid language tag \"${data.locale}\" when calling __addLocaleData(\"${data.locale}\", ...) to register new locale data.`);\r\n\r\n        addLocaleData(data, data.locale);\r\n    }\r\n});\r\n\r\nfunction addLocaleData (data, tag) {\r\n    // Both NumberFormat and DateTimeFormat require number data, so throw if it isn't present\r\n    if (!data.number)\r\n        throw new Error(\"Object passed doesn't contain locale data for Intl.NumberFormat\");\r\n\r\n    let locale,\r\n        locales = [ tag ],\r\n        parts   = tag.split('-');\r\n\r\n    // Create fallbacks for locale data with scripts, e.g. Latn, Hans, Vaii, etc\r\n    if (parts.length > 2 && parts[1].length === 4)\r\n        arrPush.call(locales, parts[0] + '-' + parts[2]);\r\n\r\n    while ((locale = arrShift.call(locales))) {\r\n        // Add to NumberFormat internal properties as per 11.2.3\r\n        arrPush.call(internals.NumberFormat['[[availableLocales]]'], locale);\r\n        internals.NumberFormat['[[localeData]]'][locale] = data.number;\r\n\r\n        // ...and DateTimeFormat internal properties as per 12.2.3\r\n        if (data.date) {\r\n            data.date.nu = data.number.nu;\r\n            arrPush.call(internals.DateTimeFormat['[[availableLocales]]'], locale);\r\n            internals.DateTimeFormat['[[localeData]]'][locale] = data.date;\r\n        }\r\n    }\r\n\r\n\r\n    // If this is the first set of locale data added, make it the default\r\n    if (defaultLocale === undefined)\r\n        setDefaultLocale(tag);\r\n}\r\n\r\ndefineProperty(Intl, '__disableRegExpRestore', {\r\n    value: function () {\r\n        internals.disableRegExpRestore = true;\r\n    }\r\n});\r\n\r\nexport default Intl;\r\n","/**\r\n* Defines regular expressions for various operations related to the BCP 47 syntax,\r\n* as defined at http://tools.ietf.org/html/bcp47#section-2.1\r\n*/\r\n\r\n// extlang       = 3ALPHA              ; selected ISO 639 codes\r\n//                 *2(\"-\" 3ALPHA)      ; permanently reserved\r\nconst extlang = '[a-z]{3}(?:-[a-z]{3}){0,2}';\r\n\r\n// language      = 2*3ALPHA            ; shortest ISO 639 code\r\n//                 [\"-\" extlang]       ; sometimes followed by\r\n//                                     ; extended language subtags\r\n//               / 4ALPHA              ; or reserved for future use\r\n//               / 5*8ALPHA            ; or registered language subtag\r\nconst language = '(?:[a-z]{2,3}(?:-' + extlang + ')?|[a-z]{4}|[a-z]{5,8})';\r\n\r\n// script        = 4ALPHA              ; ISO 15924 code\r\nconst script = '[a-z]{4}';\r\n\r\n// region        = 2ALPHA              ; ISO 3166-1 code\r\n//               / 3DIGIT              ; UN M.49 code\r\nconst region = '(?:[a-z]{2}|\\\\d{3})';\r\n\r\n// variant       = 5*8alphanum         ; registered variants\r\n//               / (DIGIT 3alphanum)\r\nconst variant = '(?:[a-z0-9]{5,8}|\\\\d[a-z0-9]{3})';\r\n\r\n//                                     ; Single alphanumerics\r\n//                                     ; \"x\" reserved for private use\r\n// singleton     = DIGIT               ; 0 - 9\r\n//               / %x41-57             ; A - W\r\n//               / %x59-5A             ; Y - Z\r\n//               / %x61-77             ; a - w\r\n//               / %x79-7A             ; y - z\r\nconst singleton = '[0-9a-wy-z]';\r\n\r\n// extension     = singleton 1*(\"-\" (2*8alphanum))\r\nconst extension = singleton + '(?:-[a-z0-9]{2,8})+';\r\n\r\n// privateuse    = \"x\" 1*(\"-\" (1*8alphanum))\r\nconst privateuse = 'x(?:-[a-z0-9]{1,8})+';\r\n\r\n// irregular     = \"en-GB-oed\"         ; irregular tags do not match\r\n//               / \"i-ami\"             ; the 'langtag' production and\r\n//               / \"i-bnn\"             ; would not otherwise be\r\n//               / \"i-default\"         ; considered 'well-formed'\r\n//               / \"i-enochian\"        ; These tags are all valid,\r\n//               / \"i-hak\"             ; but most are deprecated\r\n//               / \"i-klingon\"         ; in favor of more modern\r\n//               / \"i-lux\"             ; subtags or subtag\r\n//               / \"i-mingo\"           ; combination\r\n//               / \"i-navajo\"\r\n//               / \"i-pwn\"\r\n//               / \"i-tao\"\r\n//               / \"i-tay\"\r\n//               / \"i-tsu\"\r\n//               / \"sgn-BE-FR\"\r\n//               / \"sgn-BE-NL\"\r\n//               / \"sgn-CH-DE\"\r\nconst irregular = '(?:en-GB-oed'\r\n          + '|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)'\r\n          + '|sgn-(?:BE-FR|BE-NL|CH-DE))';\r\n\r\n// regular       = \"art-lojban\"        ; these tags match the 'langtag'\r\n//               / \"cel-gaulish\"       ; production, but their subtags\r\n//               / \"no-bok\"            ; are not extended language\r\n//               / \"no-nyn\"            ; or variant subtags: their meaning\r\n//               / \"zh-guoyu\"          ; is defined by their registration\r\n//               / \"zh-hakka\"          ; and all of these are deprecated\r\n//               / \"zh-min\"            ; in favor of a more modern\r\n//               / \"zh-min-nan\"        ; subtag or sequence of subtags\r\n//               / \"zh-xiang\"\r\nconst regular = '(?:art-lojban|cel-gaulish|no-bok|no-nyn'\r\n        + '|zh-(?:guoyu|hakka|min|min-nan|xiang))';\r\n\r\n// grandfathered = irregular           ; non-redundant tags registered\r\n//               / regular             ; during the RFC 3066 era\r\nconst grandfathered = '(?:' + irregular + '|' + regular + ')';\r\n\r\n// langtag       = language\r\n//                 [\"-\" script]\r\n//                 [\"-\" region]\r\n//                 *(\"-\" variant)\r\n//                 *(\"-\" extension)\r\n//                 [\"-\" privateuse]\r\nconst langtag = language + '(?:-' + script + ')?(?:-' + region + ')?(?:-'\r\n        + variant + ')*(?:-' + extension + ')*(?:-' + privateuse + ')?';\r\n\r\n// Language-Tag  = langtag             ; normal language tags\r\n//               / privateuse          ; private use tag\r\n//               / grandfathered       ; grandfathered tags\r\nexport let expBCP47Syntax = RegExp('^(?:'+langtag+'|'+privateuse+'|'+grandfathered+')$', 'i');\r\n\r\n// Match duplicate variants in a language tag\r\nexport let expVariantDupes = RegExp('^(?!x).*?-('+variant+')-(?:\\\\w{4,8}-(?!x-))*\\\\1\\\\b', 'i');\r\n\r\n// Match duplicate singletons in a language tag (except in private use)\r\nexport let expSingletonDupes = RegExp('^(?!x).*?-('+singleton+')-(?:\\\\w+-(?!x-))*\\\\1\\\\b', 'i');\r\n\r\n// Match all extension sequences\r\nexport let expExtSequences = RegExp('-'+extension, 'ig');\r\n","// Sect 13 Locale Sensitive Functions of the ECMAScript Language Specification\r\n// ===========================================================================\r\n\r\nimport {\r\n    Intl\r\n} from \"./8.intl.js\";\r\n\r\nimport {\r\n    FormatNumber,\r\n    NumberFormatConstructor\r\n} from \"./11.numberformat.js\";\r\n\r\nimport {\r\n    ToDateTimeOptions,\r\n    DateTimeFormatConstructor,\r\n    FormatDateTime\r\n} from \"./12.datetimeformat.js\";\r\n\r\nlet ls = Intl.__localeSensitiveProtos = {\r\n    Number: {},\r\n    Date:   {}\r\n};\r\n\r\n/**\r\n * When the toLocaleString method is called with optional arguments locales and options,\r\n * the following steps are taken:\r\n */\r\n/* 13.2.1 */ls.Number.toLocaleString = function () {\r\n    // Satisfy test 13.2.1_1\r\n    if (Object.prototype.toString.call(this) !== '[object Number]')\r\n        throw new TypeError('`this` value must be a number for Number.prototype.toLocaleString()');\r\n\r\n    // 1. Let x be this Number value (as defined in ES5, 15.7.4).\r\n    // 2. If locales is not provided, then let locales be undefined.\r\n    // 3. If options is not provided, then let options be undefined.\r\n    // 4. Let numberFormat be the result of creating a new object as if by the\r\n    //    expression new Intl.NumberFormat(locales, options) where\r\n    //    Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\r\n    // 5. Return the result of calling the FormatNumber abstract operation\r\n    //    (defined in 11.3.2) with arguments numberFormat and x.\r\n    return FormatNumber(new NumberFormatConstructor(arguments[0], arguments[1]), this);\r\n};\r\n\r\n/**\r\n * When the toLocaleString method is called with optional arguments locales and options,\r\n * the following steps are taken:\r\n */\r\n/* 13.3.1 */ls.Date.toLocaleString = function () {\r\n    // Satisfy test 13.3.0_1\r\n    if (Object.prototype.toString.call(this) !== '[object Date]')\r\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleString()');\r\n\r\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\r\n    let x = +this;\r\n\r\n    // 2. If x is NaN, then return \"Invalid Date\".\r\n    if (isNaN(x))\r\n        return 'Invalid Date';\r\n\r\n    // 3. If locales is not provided, then let locales be undefined.\r\n    let locales = arguments[0];\r\n\r\n    // 4. If options is not provided, then let options be undefined.\r\n    let options = arguments[1];\r\n\r\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\r\n    //    operation (defined in 12.1.1) with arguments options, \"any\", and \"all\".\r\n    options = ToDateTimeOptions(options, 'any', 'all');\r\n\r\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\r\n    //    expression new Intl.DateTimeFormat(locales, options) where\r\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\r\n    let dateTimeFormat = new DateTimeFormatConstructor(locales, options);\r\n\r\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\r\n    //    in 12.3.2) with arguments dateTimeFormat and x.\r\n    return FormatDateTime(dateTimeFormat, x);\r\n};\r\n\r\n/**\r\n * When the toLocaleDateString method is called with optional arguments locales and\r\n * options, the following steps are taken:\r\n */\r\n/* 13.3.2 */ls.Date.toLocaleDateString = function () {\r\n    // Satisfy test 13.3.0_1\r\n    if (Object.prototype.toString.call(this) !== '[object Date]')\r\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleDateString()');\r\n\r\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\r\n    let x = +this;\r\n\r\n    // 2. If x is NaN, then return \"Invalid Date\".\r\n    if (isNaN(x))\r\n        return 'Invalid Date';\r\n\r\n    // 3. If locales is not provided, then let locales be undefined.\r\n    let locales = arguments[0],\r\n\r\n    // 4. If options is not provided, then let options be undefined.\r\n    options = arguments[1];\r\n\r\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\r\n    //    operation (defined in 12.1.1) with arguments options, \"date\", and \"date\".\r\n    options = ToDateTimeOptions(options, 'date', 'date');\r\n\r\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\r\n    //    expression new Intl.DateTimeFormat(locales, options) where\r\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\r\n    let dateTimeFormat = new DateTimeFormatConstructor(locales, options);\r\n\r\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\r\n    //    in 12.3.2) with arguments dateTimeFormat and x.\r\n    return FormatDateTime(dateTimeFormat, x);\r\n};\r\n\r\n/**\r\n * When the toLocaleTimeString method is called with optional arguments locales and\r\n * options, the following steps are taken:\r\n */\r\n/* 13.3.3 */ls.Date.toLocaleTimeString = function () {\r\n    // Satisfy test 13.3.0_1\r\n    if (Object.prototype.toString.call(this) !== '[object Date]')\r\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleTimeString()');\r\n\r\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\r\n    let x = +this;\r\n\r\n    // 2. If x is NaN, then return \"Invalid Date\".\r\n    if (isNaN(x))\r\n        return 'Invalid Date';\r\n\r\n    // 3. If locales is not provided, then let locales be undefined.\r\n    let locales = arguments[0];\r\n\r\n    // 4. If options is not provided, then let options be undefined.\r\n    let options = arguments[1];\r\n\r\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\r\n    //    operation (defined in 12.1.1) with arguments options, \"time\", and \"time\".\r\n    options = ToDateTimeOptions(options, 'time', 'time');\r\n\r\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\r\n    //    expression new Intl.DateTimeFormat(locales, options) where\r\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\r\n    let dateTimeFormat = new DateTimeFormatConstructor(locales, options);\r\n\r\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\r\n    //    in 12.3.2) with arguments dateTimeFormat and x.\r\n    return FormatDateTime(dateTimeFormat, x);\r\n};\r\n\r\nexport default ls;\r\n","const _cp = [\nfunction(n, ord) {\n  if (ord) return 'other';\n  return 'other';\n},\nfunction(n, ord) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\nfunction(n, ord) {\n  if (ord) return 'other';\n  return ((n == 0\n          || n == 1)) ? 'one' : 'other';\n},\nfunction(n, ord) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n}\n];\n\nexport default {\naf: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nak: function(n, ord\n) {\n  if (ord) return 'other';\n  return ((n == 0\n          || n == 1)) ? 'one' : 'other';\n},\n\nam: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n >= 0 && n <= 1) ? 'one' : 'other';\n},\n\nar: function(n, ord\n) {\n  var s = String(n).split('.'), t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n  if (ord) return 'other';\n  return (n == 0) ? 'zero'\n      : (n == 1) ? 'one'\n      : (n == 2) ? 'two'\n      : ((n100 >= 3 && n100 <= 10)) ? 'few'\n      : ((n100 >= 11 && n100 <= 99)) ? 'many'\n      : 'other';\n},\n\nars: function(n, ord\n) {\n  var s = String(n).split('.'), t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n  if (ord) return 'other';\n  return (n == 0) ? 'zero'\n      : (n == 1) ? 'one'\n      : (n == 2) ? 'two'\n      : ((n100 >= 3 && n100 <= 10)) ? 'few'\n      : ((n100 >= 11 && n100 <= 99)) ? 'many'\n      : 'other';\n},\n\nas: function(n, ord\n) {\n  if (ord) return ((n == 1 || n == 5 || n == 7 || n == 8 || n == 9\n          || n == 10)) ? 'one'\n      : ((n == 2\n          || n == 3)) ? 'two'\n      : (n == 4) ? 'few'\n      : (n == 6) ? 'many'\n      : 'other';\n  return (n >= 0 && n <= 1) ? 'one' : 'other';\n},\n\nasa: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nast: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\naz: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], i10 = i.slice(-1),\n      i100 = i.slice(-2), i1000 = i.slice(-3);\n  if (ord) return ((i10 == 1 || i10 == 2 || i10 == 5 || i10 == 7 || i10 == 8)\n          || (i100 == 20 || i100 == 50 || i100 == 70\n          || i100 == 80)) ? 'one'\n      : ((i10 == 3 || i10 == 4) || (i1000 == 100 || i1000 == 200\n          || i1000 == 300 || i1000 == 400 || i1000 == 500 || i1000 == 600 || i1000 == 700\n          || i1000 == 800\n          || i1000 == 900)) ? 'few'\n      : (i == 0 || i10 == 6 || (i100 == 40 || i100 == 60\n          || i100 == 90)) ? 'many'\n      : 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nbe: function(n, ord\n) {\n  var s = String(n).split('.'), t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);\n  if (ord) return ((n10 == 2\n          || n10 == 3) && n100 != 12 && n100 != 13) ? 'few' : 'other';\n  return (n10 == 1 && n100 != 11) ? 'one'\n      : ((n10 >= 2 && n10 <= 4) && (n100 < 12\n          || n100 > 14)) ? 'few'\n      : (t0 && n10 == 0 || (n10 >= 5 && n10 <= 9)\n          || (n100 >= 11 && n100 <= 14)) ? 'many'\n      : 'other';\n},\n\nbem: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nbez: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nbg: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nbh: function(n, ord\n) {\n  if (ord) return 'other';\n  return ((n == 0\n          || n == 1)) ? 'one' : 'other';\n},\n\nbm: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nbn: function(n, ord\n) {\n  if (ord) return ((n == 1 || n == 5 || n == 7 || n == 8 || n == 9\n          || n == 10)) ? 'one'\n      : ((n == 2\n          || n == 3)) ? 'two'\n      : (n == 4) ? 'few'\n      : (n == 6) ? 'many'\n      : 'other';\n  return (n >= 0 && n <= 1) ? 'one' : 'other';\n},\n\nbo: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nbr: function(n, ord\n) {\n  var s = String(n).split('.'), t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2),\n      n1000000 = t0 && s[0].slice(-6);\n  if (ord) return 'other';\n  return (n10 == 1 && n100 != 11 && n100 != 71 && n100 != 91) ? 'one'\n      : (n10 == 2 && n100 != 12 && n100 != 72 && n100 != 92) ? 'two'\n      : (((n10 == 3 || n10 == 4) || n10 == 9) && (n100 < 10\n          || n100 > 19) && (n100 < 70 || n100 > 79) && (n100 < 90\n          || n100 > 99)) ? 'few'\n      : (n != 0 && t0 && n1000000 == 0) ? 'many'\n      : 'other';\n},\n\nbrx: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nbs: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],\n      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);\n  if (ord) return 'other';\n  return (v0 && i10 == 1 && i100 != 11\n          || f10 == 1 && f100 != 11) ? 'one'\n      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14)\n          || (f10 >= 2 && f10 <= 4) && (f100 < 12\n          || f100 > 14)) ? 'few'\n      : 'other';\n},\n\nca: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return ((n == 1\n          || n == 3)) ? 'one'\n      : (n == 2) ? 'two'\n      : (n == 4) ? 'few'\n      : 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\nce: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\ncgg: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nchr: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nckb: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\ncs: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one'\n      : ((i >= 2 && i <= 4) && v0) ? 'few'\n      : (!v0) ? 'many'\n      : 'other';\n},\n\ncy: function(n, ord\n) {\n  if (ord) return ((n == 0 || n == 7 || n == 8\n          || n == 9)) ? 'zero'\n      : (n == 1) ? 'one'\n      : (n == 2) ? 'two'\n      : ((n == 3\n          || n == 4)) ? 'few'\n      : ((n == 5\n          || n == 6)) ? 'many'\n      : 'other';\n  return (n == 0) ? 'zero'\n      : (n == 1) ? 'one'\n      : (n == 2) ? 'two'\n      : (n == 3) ? 'few'\n      : (n == 6) ? 'many'\n      : 'other';\n},\n\nda: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], t0 = Number(s[0]) == n;\n  if (ord) return 'other';\n  return (n == 1 || !t0 && (i == 0\n          || i == 1)) ? 'one' : 'other';\n},\n\nde: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\ndsb: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],\n      i100 = i.slice(-2), f100 = f.slice(-2);\n  if (ord) return 'other';\n  return (v0 && i100 == 1\n          || f100 == 1) ? 'one'\n      : (v0 && i100 == 2\n          || f100 == 2) ? 'two'\n      : (v0 && (i100 == 3 || i100 == 4) || (f100 == 3\n          || f100 == 4)) ? 'few'\n      : 'other';\n},\n\ndv: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\ndz: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nee: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nel: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nen: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);\n  if (ord) return (n10 == 1 && n100 != 11) ? 'one'\n      : (n10 == 2 && n100 != 12) ? 'two'\n      : (n10 == 3 && n100 != 13) ? 'few'\n      : 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\neo: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nes: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\net: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\neu: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nfa: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n >= 0 && n <= 1) ? 'one' : 'other';\n},\n\nff: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n >= 0 && n < 2) ? 'one' : 'other';\n},\n\nfi: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\nfil: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],\n      i10 = i.slice(-1), f10 = f.slice(-1);\n  if (ord) return (n == 1) ? 'one' : 'other';\n  return (v0 && (i == 1 || i == 2 || i == 3)\n          || v0 && i10 != 4 && i10 != 6 && i10 != 9\n          || !v0 && f10 != 4 && f10 != 6 && f10 != 9) ? 'one' : 'other';\n},\n\nfo: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nfr: function(n, ord\n) {\n  if (ord) return (n == 1) ? 'one' : 'other';\n  return (n >= 0 && n < 2) ? 'one' : 'other';\n},\n\nfur: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nfy: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\nga: function(n, ord\n) {\n  var s = String(n).split('.'), t0 = Number(s[0]) == n;\n  if (ord) return (n == 1) ? 'one' : 'other';\n  return (n == 1) ? 'one'\n      : (n == 2) ? 'two'\n      : ((t0 && n >= 3 && n <= 6)) ? 'few'\n      : ((t0 && n >= 7 && n <= 10)) ? 'many'\n      : 'other';\n},\n\ngd: function(n, ord\n) {\n  var s = String(n).split('.'), t0 = Number(s[0]) == n;\n  if (ord) return ((n == 1\n          || n == 11)) ? 'one'\n      : ((n == 2\n          || n == 12)) ? 'two'\n      : ((n == 3\n          || n == 13)) ? 'few'\n      : 'other';\n  return ((n == 1\n          || n == 11)) ? 'one'\n      : ((n == 2\n          || n == 12)) ? 'two'\n      : (((t0 && n >= 3 && n <= 10)\n          || (t0 && n >= 13 && n <= 19))) ? 'few'\n      : 'other';\n},\n\ngl: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\ngsw: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\ngu: function(n, ord\n) {\n  if (ord) return (n == 1) ? 'one'\n      : ((n == 2\n          || n == 3)) ? 'two'\n      : (n == 4) ? 'few'\n      : (n == 6) ? 'many'\n      : 'other';\n  return (n >= 0 && n <= 1) ? 'one' : 'other';\n},\n\nguw: function(n, ord\n) {\n  if (ord) return 'other';\n  return ((n == 0\n          || n == 1)) ? 'one' : 'other';\n},\n\ngv: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], v0 = !s[1], i10 = i.slice(-1),\n      i100 = i.slice(-2);\n  if (ord) return 'other';\n  return (v0 && i10 == 1) ? 'one'\n      : (v0 && i10 == 2) ? 'two'\n      : (v0 && (i100 == 0 || i100 == 20 || i100 == 40 || i100 == 60\n          || i100 == 80)) ? 'few'\n      : (!v0) ? 'many'\n      : 'other';\n},\n\nha: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nhaw: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nhe: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], v0 = !s[1], t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1);\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one'\n      : (i == 2 && v0) ? 'two'\n      : (v0 && (n < 0\n          || n > 10) && t0 && n10 == 0) ? 'many'\n      : 'other';\n},\n\nhi: function(n, ord\n) {\n  if (ord) return (n == 1) ? 'one'\n      : ((n == 2\n          || n == 3)) ? 'two'\n      : (n == 4) ? 'few'\n      : (n == 6) ? 'many'\n      : 'other';\n  return (n >= 0 && n <= 1) ? 'one' : 'other';\n},\n\nhr: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],\n      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);\n  if (ord) return 'other';\n  return (v0 && i10 == 1 && i100 != 11\n          || f10 == 1 && f100 != 11) ? 'one'\n      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14)\n          || (f10 >= 2 && f10 <= 4) && (f100 < 12\n          || f100 > 14)) ? 'few'\n      : 'other';\n},\n\nhsb: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],\n      i100 = i.slice(-2), f100 = f.slice(-2);\n  if (ord) return 'other';\n  return (v0 && i100 == 1\n          || f100 == 1) ? 'one'\n      : (v0 && i100 == 2\n          || f100 == 2) ? 'two'\n      : (v0 && (i100 == 3 || i100 == 4) || (f100 == 3\n          || f100 == 4)) ? 'few'\n      : 'other';\n},\n\nhu: function(n, ord\n) {\n  if (ord) return ((n == 1\n          || n == 5)) ? 'one' : 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nhy: function(n, ord\n) {\n  if (ord) return (n == 1) ? 'one' : 'other';\n  return (n >= 0 && n < 2) ? 'one' : 'other';\n},\n\nia: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\nid: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nig: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nii: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\n\"in\": function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nio: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\nis: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], t0 = Number(s[0]) == n,\n      i10 = i.slice(-1), i100 = i.slice(-2);\n  if (ord) return 'other';\n  return (t0 && i10 == 1 && i100 != 11\n          || !t0) ? 'one' : 'other';\n},\n\nit: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return ((n == 11 || n == 8 || n == 80\n          || n == 800)) ? 'many' : 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\niu: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one'\n      : (n == 2) ? 'two'\n      : 'other';\n},\n\niw: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], v0 = !s[1], t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1);\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one'\n      : (i == 2 && v0) ? 'two'\n      : (v0 && (n < 0\n          || n > 10) && t0 && n10 == 0) ? 'many'\n      : 'other';\n},\n\nja: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\njbo: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\njgo: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nji: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\njmc: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\njv: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\njw: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nka: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], i100 = i.slice(-2);\n  if (ord) return (i == 1) ? 'one'\n      : (i == 0 || ((i100 >= 2 && i100 <= 20) || i100 == 40 || i100 == 60\n          || i100 == 80)) ? 'many'\n      : 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nkab: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n >= 0 && n < 2) ? 'one' : 'other';\n},\n\nkaj: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nkcg: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nkde: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nkea: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nkk: function(n, ord\n) {\n  var s = String(n).split('.'), t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1);\n  if (ord) return (n10 == 6 || n10 == 9\n          || t0 && n10 == 0 && n != 0) ? 'many' : 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nkkj: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nkl: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nkm: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nkn: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n >= 0 && n <= 1) ? 'one' : 'other';\n},\n\nko: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nks: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nksb: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nksh: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 0) ? 'zero'\n      : (n == 1) ? 'one'\n      : 'other';\n},\n\nku: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nkw: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one'\n      : (n == 2) ? 'two'\n      : 'other';\n},\n\nky: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nlag: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0];\n  if (ord) return 'other';\n  return (n == 0) ? 'zero'\n      : ((i == 0\n          || i == 1) && n != 0) ? 'one'\n      : 'other';\n},\n\nlb: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nlg: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nlkt: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nln: function(n, ord\n) {\n  if (ord) return 'other';\n  return ((n == 0\n          || n == 1)) ? 'one' : 'other';\n},\n\nlo: function(n, ord\n) {\n  if (ord) return (n == 1) ? 'one' : 'other';\n  return 'other';\n},\n\nlt: function(n, ord\n) {\n  var s = String(n).split('.'), f = s[1] || '', t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);\n  if (ord) return 'other';\n  return (n10 == 1 && (n100 < 11\n          || n100 > 19)) ? 'one'\n      : ((n10 >= 2 && n10 <= 9) && (n100 < 11\n          || n100 > 19)) ? 'few'\n      : (f != 0) ? 'many'\n      : 'other';\n},\n\nlv: function(n, ord\n) {\n  var s = String(n).split('.'), f = s[1] || '', v = f.length,\n      t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2), f100 = f.slice(-2), f10 = f.slice(-1);\n  if (ord) return 'other';\n  return (t0 && n10 == 0 || (n100 >= 11 && n100 <= 19)\n          || v == 2 && (f100 >= 11 && f100 <= 19)) ? 'zero'\n      : (n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11\n          || v != 2 && f10 == 1) ? 'one'\n      : 'other';\n},\n\nmas: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nmg: function(n, ord\n) {\n  if (ord) return 'other';\n  return ((n == 0\n          || n == 1)) ? 'one' : 'other';\n},\n\nmgo: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nmk: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],\n      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);\n  if (ord) return (i10 == 1 && i100 != 11) ? 'one'\n      : (i10 == 2 && i100 != 12) ? 'two'\n      : ((i10 == 7\n          || i10 == 8) && i100 != 17 && i100 != 18) ? 'many'\n      : 'other';\n  return (v0 && i10 == 1 && i100 != 11\n          || f10 == 1 && f100 != 11) ? 'one' : 'other';\n},\n\nml: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nmn: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nmo: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n  if (ord) return (n == 1) ? 'one' : 'other';\n  return (n == 1 && v0) ? 'one'\n      : (!v0 || n == 0\n          || n != 1 && (n100 >= 1 && n100 <= 19)) ? 'few'\n      : 'other';\n},\n\nmr: function(n, ord\n) {\n  if (ord) return (n == 1) ? 'one'\n      : ((n == 2\n          || n == 3)) ? 'two'\n      : (n == 4) ? 'few'\n      : 'other';\n  return (n >= 0 && n <= 1) ? 'one' : 'other';\n},\n\nms: function(n, ord\n) {\n  if (ord) return (n == 1) ? 'one' : 'other';\n  return 'other';\n},\n\nmt: function(n, ord\n) {\n  var s = String(n).split('.'), t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n  if (ord) return 'other';\n  return (n == 1) ? 'one'\n      : (n == 0\n          || (n100 >= 2 && n100 <= 10)) ? 'few'\n      : ((n100 >= 11 && n100 <= 19)) ? 'many'\n      : 'other';\n},\n\nmy: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nnah: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nnaq: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one'\n      : (n == 2) ? 'two'\n      : 'other';\n},\n\nnb: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nnd: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nne: function(n, ord\n) {\n  var s = String(n).split('.'), t0 = Number(s[0]) == n;\n  if (ord) return ((t0 && n >= 1 && n <= 4)) ? 'one' : 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nnl: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\nnn: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nnnh: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nno: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nnqo: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nnr: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nnso: function(n, ord\n) {\n  if (ord) return 'other';\n  return ((n == 0\n          || n == 1)) ? 'one' : 'other';\n},\n\nny: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nnyn: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nom: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nor: function(n, ord\n) {\n  var s = String(n).split('.'), t0 = Number(s[0]) == n;\n  if (ord) return ((n == 1 || n == 5\n          || (t0 && n >= 7 && n <= 9))) ? 'one'\n      : ((n == 2\n          || n == 3)) ? 'two'\n      : (n == 4) ? 'few'\n      : (n == 6) ? 'many'\n      : 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nos: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\npa: function(n, ord\n) {\n  if (ord) return 'other';\n  return ((n == 0\n          || n == 1)) ? 'one' : 'other';\n},\n\npap: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\npl: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], v0 = !s[1], i10 = i.slice(-1),\n      i100 = i.slice(-2);\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one'\n      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12\n          || i100 > 14)) ? 'few'\n      : (v0 && i != 1 && (i10 == 0 || i10 == 1)\n          || v0 && (i10 >= 5 && i10 <= 9)\n          || v0 && (i100 >= 12 && i100 <= 14)) ? 'many'\n      : 'other';\n},\n\nprg: function(n, ord\n) {\n  var s = String(n).split('.'), f = s[1] || '', v = f.length,\n      t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2), f100 = f.slice(-2), f10 = f.slice(-1);\n  if (ord) return 'other';\n  return (t0 && n10 == 0 || (n100 >= 11 && n100 <= 19)\n          || v == 2 && (f100 >= 11 && f100 <= 19)) ? 'zero'\n      : (n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11\n          || v != 2 && f10 == 1) ? 'one'\n      : 'other';\n},\n\nps: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\npt: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0];\n  if (ord) return 'other';\n  return ((i == 0\n          || i == 1)) ? 'one' : 'other';\n},\n\n\"pt-PT\": function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\nrm: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nro: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n  if (ord) return (n == 1) ? 'one' : 'other';\n  return (n == 1 && v0) ? 'one'\n      : (!v0 || n == 0\n          || n != 1 && (n100 >= 1 && n100 <= 19)) ? 'few'\n      : 'other';\n},\n\nrof: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nroot: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nru: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], v0 = !s[1], i10 = i.slice(-1),\n      i100 = i.slice(-2);\n  if (ord) return 'other';\n  return (v0 && i10 == 1 && i100 != 11) ? 'one'\n      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12\n          || i100 > 14)) ? 'few'\n      : (v0 && i10 == 0 || v0 && (i10 >= 5 && i10 <= 9)\n          || v0 && (i100 >= 11 && i100 <= 14)) ? 'many'\n      : 'other';\n},\n\nrwk: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nsah: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nsaq: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nsc: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return ((n == 11 || n == 8 || n == 80\n          || n == 800)) ? 'many' : 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\nscn: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return ((n == 11 || n == 8 || n == 80\n          || n == 800)) ? 'many' : 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\nsd: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nsdh: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nse: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one'\n      : (n == 2) ? 'two'\n      : 'other';\n},\n\nseh: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nses: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nsg: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nsh: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],\n      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);\n  if (ord) return 'other';\n  return (v0 && i10 == 1 && i100 != 11\n          || f10 == 1 && f100 != 11) ? 'one'\n      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14)\n          || (f10 >= 2 && f10 <= 4) && (f100 < 12\n          || f100 > 14)) ? 'few'\n      : 'other';\n},\n\nshi: function(n, ord\n) {\n  var s = String(n).split('.'), t0 = Number(s[0]) == n;\n  if (ord) return 'other';\n  return (n >= 0 && n <= 1) ? 'one'\n      : ((t0 && n >= 2 && n <= 10)) ? 'few'\n      : 'other';\n},\n\nsi: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], f = s[1] || '';\n  if (ord) return 'other';\n  return ((n == 0 || n == 1)\n          || i == 0 && f == 1) ? 'one' : 'other';\n},\n\nsk: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one'\n      : ((i >= 2 && i <= 4) && v0) ? 'few'\n      : (!v0) ? 'many'\n      : 'other';\n},\n\nsl: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], v0 = !s[1], i100 = i.slice(-2);\n  if (ord) return 'other';\n  return (v0 && i100 == 1) ? 'one'\n      : (v0 && i100 == 2) ? 'two'\n      : (v0 && (i100 == 3 || i100 == 4)\n          || !v0) ? 'few'\n      : 'other';\n},\n\nsma: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one'\n      : (n == 2) ? 'two'\n      : 'other';\n},\n\nsmi: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one'\n      : (n == 2) ? 'two'\n      : 'other';\n},\n\nsmj: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one'\n      : (n == 2) ? 'two'\n      : 'other';\n},\n\nsmn: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one'\n      : (n == 2) ? 'two'\n      : 'other';\n},\n\nsms: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one'\n      : (n == 2) ? 'two'\n      : 'other';\n},\n\nsn: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nso: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nsq: function(n, ord\n) {\n  var s = String(n).split('.'), t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);\n  if (ord) return (n == 1) ? 'one'\n      : (n10 == 4 && n100 != 14) ? 'many'\n      : 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nsr: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],\n      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);\n  if (ord) return 'other';\n  return (v0 && i10 == 1 && i100 != 11\n          || f10 == 1 && f100 != 11) ? 'one'\n      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14)\n          || (f10 >= 2 && f10 <= 4) && (f100 < 12\n          || f100 > 14)) ? 'few'\n      : 'other';\n},\n\nss: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nssy: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nst: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nsv: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);\n  if (ord) return ((n10 == 1\n          || n10 == 2) && n100 != 11 && n100 != 12) ? 'one' : 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\nsw: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\nsyr: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nta: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nte: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nteo: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nth: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nti: function(n, ord\n) {\n  if (ord) return 'other';\n  return ((n == 0\n          || n == 1)) ? 'one' : 'other';\n},\n\ntig: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\ntk: function(n, ord\n) {\n  var s = String(n).split('.'), t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1);\n  if (ord) return ((n10 == 6 || n10 == 9)\n          || n == 10) ? 'few' : 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\ntl: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],\n      i10 = i.slice(-1), f10 = f.slice(-1);\n  if (ord) return (n == 1) ? 'one' : 'other';\n  return (v0 && (i == 1 || i == 2 || i == 3)\n          || v0 && i10 != 4 && i10 != 6 && i10 != 9\n          || !v0 && f10 != 4 && f10 != 6 && f10 != 9) ? 'one' : 'other';\n},\n\ntn: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nto: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\ntr: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nts: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\ntzm: function(n, ord\n) {\n  var s = String(n).split('.'), t0 = Number(s[0]) == n;\n  if (ord) return 'other';\n  return ((n == 0 || n == 1)\n          || (t0 && n >= 11 && n <= 99)) ? 'one' : 'other';\n},\n\nug: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nuk: function(n, ord\n) {\n  var s = String(n).split('.'), i = s[0], v0 = !s[1], t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), i10 = i.slice(-1),\n      i100 = i.slice(-2);\n  if (ord) return (n10 == 3 && n100 != 13) ? 'few' : 'other';\n  return (v0 && i10 == 1 && i100 != 11) ? 'one'\n      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12\n          || i100 > 14)) ? 'few'\n      : (v0 && i10 == 0 || v0 && (i10 >= 5 && i10 <= 9)\n          || v0 && (i100 >= 11 && i100 <= 14)) ? 'many'\n      : 'other';\n},\n\nur: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\nuz: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nve: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nvi: function(n, ord\n) {\n  if (ord) return (n == 1) ? 'one' : 'other';\n  return 'other';\n},\n\nvo: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nvun: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nwa: function(n, ord\n) {\n  if (ord) return 'other';\n  return ((n == 0\n          || n == 1)) ? 'one' : 'other';\n},\n\nwae: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nwo: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nxh: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nxog: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n == 1) ? 'one' : 'other';\n},\n\nyi: function(n, ord\n) {\n  var s = String(n).split('.'), v0 = !s[1];\n  if (ord) return 'other';\n  return (n == 1 && v0) ? 'one' : 'other';\n},\n\nyo: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nyue: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nzh: function(n, ord\n) {\n  if (ord) return 'other';\n  return 'other';\n},\n\nzu: function(n, ord\n) {\n  if (ord) return 'other';\n  return (n >= 0 && n <= 1) ? 'one' : 'other';\n}\n}\n","import IntlPolyfill from \"./core.js\";\r\n\r\n// hack to export the polyfill as global Intl if needed\r\nif (typeof Intl === 'undefined') {\r\n    try {\r\n        window.Intl = IntlPolyfill;\r\n        IntlPolyfill.__applyLocaleSensitivePrototypes();\r\n    } catch (e) {\r\n        // can be read only property\r\n    }\r\n}\r\n\r\nexport default IntlPolyfill;\r\n"],"names":["log10Floor","n","Math","log10","floor","x","round","log","LOG10E","Number","Record","obj","k","hop","call","defineProperty","this","value","enumerable","writable","configurable","List","arguments","length","arrPush","apply","arrSlice","createRegExpRestore","internals","disableRegExpRestore","regExpCache","RegExp","lastMatch","leftContext","multiline","input","has","i","esc","replace","exprStr","m","substring","indexOf","match","expr","lastIndex","exec","toObject","arg","TypeError","Object","toNumber","toInteger","number","isNaN","Infinity","abs","toLength","len","pow","min","getInternalProperties","__getInternalProperties","secret","objCreate","setDefaultLocale","locale","toLatinUpperCase","str","ch","charAt","slice","toUpperCase","IsStructurallyValidLanguageTag","expBCP47Syntax","test","expVariantDupes","expSingletonDupes","CanonicalizeLanguageTag","parts","toLowerCase","split","max","arrJoin","expExtSequences","sort","source","redundantTags","tags","subtags","extLang","DefaultLocale","defaultLocale","IsWellFormedCurrencyCode","currency","c","String","normalized","expCurrencyCode","CanonicalizeLocaleList","locales","undefined","seen","O","Pk","kValue","tag","RangeError","arrIndexOf","BestAvailableLocale","availableLocales","candidate","pos","lastIndexOf","LookupMatcher","requestedLocales","availableLocale","noExtensionsLocale","expUnicodeExSeq","result","extension","extensionIndex","BestFitMatcher","UnicodeExtensionSubtags","size","extensionSubtags","attribute","q","p","t","codePointAt","type","push","key","attr","tail","ResolveLocale","options","relevantExtensionKeys","localeData","ReferenceError","matcher","r","foundLocale","extensionSubtagsLength","supportedExtension","foundLocaleData","keyLocaleData","supportedExtensionAddition","keyPos","requestedValue","valuePos","optionsValue","privateIndex","LookupSupportedLocales","subset","BestFitSupportedLocales","SupportedLocales","localeMatcher","P","GetOption","property","values","fallback","Boolean","GetNumberOption","minimum","maximum","getCanonicalLocales","ll","NumberFormatConstructor","Intl","InitializeNumberFormat","NumberFormat","SetNumberFormatDigitOptions","intlObj","mnfdDefault","mnid","mnfd","mxfd","mnsd","minimumSignificantDigits","mxsd","maximumSignificantDigits","numberFormat","internal","regexpRestore","opt","dataLocale","s","cDigits","CurrencyDigits","cd","g","dataLocaleData","patterns","stylePatterns","positivePattern","negativePattern","es3","format","GetFormatNumber","currencyMinorUnits","babelHelpers","F","FormatNumber","bf","fnBind","formatToParts","FormatNumberToParts","PartitionNumberPattern","part","FormatNumberToString","ToRawPrecision","ToRawFixed","nums","data","ild","symbols","latn","pattern","beginIndex","endIndex","nextIndex","Error","literal","[[type]]","[[value]]","nan","isFinite","numSys","digits","digit","integer","fraction","decimalSepIndex","groupSepSymbol","group","groups","pgSize","primaryGroupSize","sgSize","secondaryGroupSize","end","idx","start","integerGroup","arrShift","decimalSepSymbol","decimal","infinity","plusSignSymbol","plusSign","minusSignSymbol","minusSign","percentSignSymbol","percentSign","currencies","minPrecision","maxPrecision","e","Array","f","exp","LN10","cut","minInteger","minFraction","maxFraction","toFixed","int","a","isDateFormatOnly","tmKeys","hasOwnProperty","isTimeFormatOnly","dtKeys","joinDateAndTimeFormats","dateFormatObj","timeFormatObj","o","_","j","computeFinalPatterns","formatObj","pattern12","extendedPattern","$0","expPatternTrimmer","expDTComponentsMeta","era","year","quarter","month","week","day","weekday","hour12","hour","minute","second","timeZoneName","createDateTimeFormat","skeleton","unwantedDTCs","expDTComponents","createDateTimeFormats","formats","availableFormats","timeFormats","dateFormats","computed","timeRelatedFormats","dateRelatedFormats","full","long","medium","short","originalPattern","generateSyntheticFormat","propName","propValue","validSyntheticProps","resolveDateString","ca","component","width","gregory","alts","resolved","DateTimeFormatConstructor","InitializeDateTimeFormat","DateTimeFormat","dateTimeFormat","ToDateTimeOptions","tz","timeZone","prop","dateTimeComponents","bestFormat","ToDateTimeFormats","BasicFormatMatcher","hr12","BestFitFormatMatcher","hourNo0","GetFormatDateTime","prototype","toString","required","defaults","opt2","needDefaults","bestScore","score","optionsProp","formatProp","optionsPropIndex","formatPropIndex","delta","optionsPropNames","patternProp","date","FormatDateTime","Date","now","FormatToPartsDateTime","CreateDateTimeParts","nf","useGrouping","nf2","minimumIntegerDigits","tm","ToLocalTime","index","calendars","fv","v","dateWidths","substr","calendar","d","PluralRules","InitializePluralRules","pluralRules","PluralRuleSelection","l","pf","plurals","ResolvePlural","addLocaleData","nu","realDefineProp","sentinel","__defineGetter__","name","desc","get","search","create","proto","props","arrConcat","concat","join","shift","Function","bind","thisObj","fn","args","random","variant","singleton","BYR","XOF","BIF","XAF","CLF","CLP","KMF","DJF","GNF","ISK","IQD","JPY","JOD","KRW","KWD","LYD","PYG","RWF","TND","UGX","UYI","VUV","VND","descs","narrow","dateTimeParts","2-digit","numeric","getFormatFromOptions","keys","forEach","ls","__localeSensitiveProtos","toLocaleString","toLocaleDateString","toLocaleTimeString","ord","t0","n100","v0","i10","i100","i1000","n10","n1000000","f10","f100","IntlPolyfill","__applyLocaleSensitivePrototypes"],"mappings":"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BAAgC,KAG/E9U,GAAoB/C,OAAO,iDAAoD,KAG/EsD,GAAkBtD,OAAO,IAAI0F,GAAW,MRnFxC5B,UAMLL;ssBAEgB,cACL,cACA,cACA,kBACI,cACJ,gBACG,aACH,cACA,cACA,cACA,eACC,cACA,iBACG,kBACA,kBACA,iBACD,iBACA,mBACE,iBACF,eACF,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,oBACK,yBACA,oBACL,eACA,eACA,mBAGN,QACA,QACA,QACA,QACA,QACA,YACI,aACF,QACF,QACA,QACA,QACA,SACC,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,qBAGC,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,YACP,MAAO,WACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,WACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,WACP,MAAO,WACP,MAAO,YACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,YACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,YACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,MAAO,WACP,MAAO,YACP,MAAO,YACP,MAAO,YACP,M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"}